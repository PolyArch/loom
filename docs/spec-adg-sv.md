# ADG SystemVerilog Generation Specification

## Overview

This document specifies the SystemVerilog output format generated by
`ADGBuilder::exportSV()`. The output is a hierarchical RTL design consisting of
parameterized modules that can be synthesized for FPGA or ASIC targets.

For the overall ADG design, see [spec-adg.md](./spec-adg.md).
For the builder API, see [spec-adg-api.md](./spec-adg-api.md).
For simulation tools and waveform formats, see [spec-adg-tools.md](./spec-adg-tools.md).

## File Organization

### Loom Source (Implementation)

The export implementation and parameterized templates are part of the Loom
source tree:

```
include/loom/Hardware/SystemVerilog/
  # Parameterized module templates (used by exporter, NOT referenced by output)

lib/loom/Hardware/SystemVerilog/
  ADGExportSV.cpp        # Export implementation
```

### Generated Output (Self-Contained)

Self-contained output is guaranteed by
[spec-adg.md](./spec-adg.md). This document defines the generated SystemVerilog
file set and module structure.

Given `exportSV(directory)` with module name `my_cgra`, the following files are
generated:

```
  <directory>/
  my_cgra_top.sv           # Top-level module with all instantiations
  my_cgra_config.sv        # config_mem controller with AXI-Lite interface
  my_cgra_addr.h           # C header with address definitions
  lib/                     # Library modules (copied from Loom templates)
    fabric_pe.sv           # Parameterized PE module
    fabric_pe_constant.sv  # Parameterized constant PE module
    fabric_pe_load.sv      # Parameterized load PE module
    fabric_pe_store.sv     # Parameterized store PE module
    fabric_temporal_pe.sv  # Parameterized temporal PE module
    fabric_switch.sv       # Parameterized switch module
    fabric_temporal_sw.sv  # Parameterized temporal switch module
    fabric_memory.sv       # Parameterized memory module
    fabric_extmemory.sv    # Parameterized external memory module
    fabric_add_tag.sv      # Parameterized add_tag module
    fabric_map_tag.sv      # Parameterized map_tag module
    fabric_del_tag.sv      # Parameterized del_tag module
    fabric_common.svh      # Common definitions and interfaces (includes fabric_stream)
```

## Module Hierarchy

### Top-Level Module

The top-level module (`my_cgra_top.sv`) contains:

1. Module interface matching `fabric.module` ports
2. config_mem controller instantiation
3. All fabric operation instantiations
4. Internal signal wiring

**Interface structure:**

```systemverilog
module my_cgra_top #(
    parameter DATA_WIDTH = 32,
    parameter TAG_WIDTH = 4,
    parameter ADDR_WIDTH = 32
) (
    // Clock and reset
    input  logic clk,
    input  logic rst_n,

    // AXI-Lite configuration interface
    input  logic [ADDR_WIDTH-1:0] cfg_awaddr,
    input  logic                  cfg_awvalid,
    output logic                  cfg_awready,
    input  logic [31:0]           cfg_wdata,
    input  logic [3:0]            cfg_wstrb,
    input  logic                  cfg_wvalid,
    output logic                  cfg_wready,
    output logic [1:0]            cfg_bresp,
    output logic                  cfg_bvalid,
    input  logic                  cfg_bready,
    input  logic [ADDR_WIDTH-1:0] cfg_araddr,
    input  logic                  cfg_arvalid,
    output logic                  cfg_arready,
    output logic [31:0]           cfg_rdata,
    output logic [1:0]            cfg_rresp,
    output logic                  cfg_rvalid,
    input  logic                  cfg_rready,

    // Memref ports (AXI Master interfaces)
    // ... generated based on fabric.module interface

    // Native streaming ports (AXI-Stream interfaces)
    // ... generated based on fabric.module interface

    // Tagged streaming ports (AXI-Stream with sideband)
    // ... generated based on fabric.module interface

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

### Parameterized Fabric Modules

Each fabric operation type has a corresponding parameterized SystemVerilog
module. Parameters correspond to hardware attributes from the Fabric MLIR spec.
`CONFIG_WIDTH` formulas remain authoritative in
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md); derived expressions in
the snippets below are implementation illustrations.

#### fabric_pe.sv

```systemverilog
module fabric_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int IN_DATA_WIDTH [NUM_INPUTS] = '{default: 32},
    parameter int OUT_DATA_WIDTH [NUM_OUTPUTS] = '{default: 32},
    parameter int TAG_WIDTH = 0,      // 0 means native interface
    // Derived by exporter from PE-body analysis; not user-authored.
    parameter bit HAS_DATAFLOW_STREAM = 0,
    parameter int LATENCY_MIN = 1,
    parameter int LATENCY_TYP = 1,
    parameter int LATENCY_MAX = 1,
    parameter int INTERVAL_MIN = 1,
    parameter int INTERVAL_TYP = 1,
    parameter int INTERVAL_MAX = 1,
    // CONFIG_WIDTH: derived, not overridable
    //   Tagged non-constant non-load/store PE: NUM_OUTPUTS * TAG_WIDTH
    //   dataflow.stream PE:       +5 bits cont_cond_sel (one-hot)
    //   Other native compute PEs: 0
    localparam int STREAM_CONT_COND_WIDTH = HAS_DATAFLOW_STREAM ? 5 : 0,
    localparam int CONFIG_WIDTH =
        ((TAG_WIDTH > 0) ? NUM_OUTPUTS * TAG_WIDTH : 0) + STREAM_CONT_COND_WIDTH
) (
    input  logic clk,
    input  logic rst_n,

    // Input ports (valid/ready per port)
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,

    // Output ports (valid/ready per port)
    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,

    // Generic configuration data (derived CONFIG_WIDTH)
    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);

// Per-port data wires with individual widths.
// Accessed as gen_in[i].data and gen_out[o].data.
generate
    for (genvar i = 0; i < NUM_INPUTS; i++) begin : gen_in
        wire [IN_DATA_WIDTH[i]+TAG_WIDTH-1:0] data;
    end
    for (genvar o = 0; o < NUM_OUTPUTS; o++) begin : gen_out
        wire [OUT_DATA_WIDTH[o]+TAG_WIDTH-1:0] data;
    end
endgenerate
```

#### Constant PE Variant

A constant PE contains exactly one `handshake.constant` in its body. The
constant value is runtime configurable via config_mem.
Constant PEs have exactly one output.

```systemverilog
module fabric_pe_constant #(
    parameter int OUT_DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int LATENCY_MIN = 0,
    parameter int LATENCY_TYP = 0,
    parameter int LATENCY_MAX = 0,
    parameter int INTERVAL_MIN = 1,
    parameter int INTERVAL_TYP = 1,
    parameter int INTERVAL_MAX = 1,
    // CONFIG_WIDTH: derived
    //   Native:  bitwidth(constant_value)
    //   Tagged:  bitwidth(constant_value) + TAG_WIDTH
    localparam int CONST_WIDTH = OUT_DATA_WIDTH,
    localparam int CONFIG_WIDTH = (TAG_WIDTH > 0)
        ? CONST_WIDTH + TAG_WIDTH : CONST_WIDTH
) (
    input  logic clk,
    input  logic rst_n,

    output logic                          out_valid,
    input  logic                          out_ready,
    output logic [OUT_DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);
```

No input ports: the constant value comes from `cfg_data`. See
[spec-fabric-pe.md](./spec-fabric-pe.md) for constant exclusivity rules.

#### Load PE Variant

A load PE contains exactly one `handshake.load` in its body.

```systemverilog
module fabric_pe_load #(
    parameter int ADDR_WIDTH = 32,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    parameter int LQ_DEPTH = 0,       // Required when HARDWARE_TYPE = 1
    // CONFIG_WIDTH: derived
    //   TagOverwrite (tagged):  TAG_WIDTH (output_tag)
    //   TagOverwrite (native):  0
    //   TagTransparent:         0 (no output_tag)
    localparam int CONFIG_WIDTH = (HARDWARE_TYPE == 0 && TAG_WIDTH > 0)
        ? TAG_WIDTH : 0
) (
    input  logic clk,
    input  logic rst_n,

    // From compute: address
    input  logic                          addr_valid,
    output logic                          addr_ready,
    input  logic [ADDR_WIDTH+TAG_WIDTH-1:0] addr_data,

    // From memory: returned data
    input  logic                          mem_data_valid,
    output logic                          mem_data_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_data,

    // Control token
    input  logic                          ctrl_valid,
    output logic                          ctrl_ready,

    // To memory: address
    output logic                          mem_addr_valid,
    input  logic                          mem_addr_ready,
    output logic [ADDR_WIDTH+TAG_WIDTH-1:0] mem_addr_data,

    // To compute: data
    output logic                          data_valid,
    input  logic                          data_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] data_out,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
(TagOverwrite vs TagTransparent) and port role definitions.
Load/store PE latency and interval are fixed hardware behavior and are not
module parameters.

#### Store PE Variant

A store PE contains exactly one `handshake.store` in its body.

```systemverilog
module fabric_pe_store #(
    parameter int ADDR_WIDTH = 32,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    parameter int SQ_DEPTH = 0,       // Required when HARDWARE_TYPE = 1
    localparam int CONFIG_WIDTH = (HARDWARE_TYPE == 0 && TAG_WIDTH > 0)
        ? TAG_WIDTH : 0
) (
    input  logic clk,
    input  logic rst_n,

    // From compute: address
    input  logic                          addr_valid,
    output logic                          addr_ready,
    input  logic [ADDR_WIDTH+TAG_WIDTH-1:0] addr_data,

    // From compute: data
    input  logic                          data_valid,
    output logic                          data_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] data_in,

    // Control token
    input  logic                          ctrl_valid,
    output logic                          ctrl_ready,

    // To memory: address
    output logic                          mem_addr_valid,
    input  logic                          mem_addr_ready,
    output logic [ADDR_WIDTH+TAG_WIDTH-1:0] mem_addr_data,

    // To memory: data
    output logic                          mem_data_valid,
    input  logic                          mem_data_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_data_out,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
and port role definitions.
Load/store PE latency and interval are fixed hardware behavior and are not
module parameters.

#### fabric_temporal_pe.sv

```systemverilog
module fabric_temporal_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_REGISTERS = 4,
    parameter int NUM_INSTRUCTIONS = 16,
    parameter int REG_FIFO_DEPTH = 2,
    parameter int NUM_FU_TYPES = 2,
    // Placeholder default only. Exporter must emit the derived per-instance
    // width from spec-fabric-temporal_pe.md.
    parameter int INSTRUCTION_WIDTH = 64,
    // Operand buffer mode parameters
    parameter bit ENABLE_SHARE_OPERAND_BUFFER = 0,  // 0=Mode A, 1=Mode B
    parameter int OPERAND_BUFFER_SIZE = 0            // Mode B only, range [1,8192]
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface (instruction_mem only, no operand buffers)
    input  logic [NUM_INSTRUCTIONS-1:0][INSTRUCTION_WIDTH-1:0] cfg_instruction_mem,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

**Note:** The operand buffer is internal to the module and not part of
`cfg_instruction_mem`. Mode A uses `NUM_INSTRUCTIONS * NUM_INPUTS * (1 + DATA_WIDTH)`
bits internally. Mode B uses `OPERAND_BUFFER_SIZE` entries with per-tag FIFO semantics.
`INSTRUCTION_WIDTH = 64` is only a placeholder default in the template
signature.

Representation note: this SystemVerilog view uses a 2D packed array for
`cfg_instruction_mem`, while the SystemC view uses a flat bitvector. They are
bit-equivalent representations of the same packed instruction memory, with
packing/bit-order authority defined by
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md).

Recommended defensive check (compile-time/elaboration-time):

```systemverilog
localparam int OPERAND_CONFIG_WIDTH =
    (NUM_REGISTERS > 0) ? (1 + $clog2(NUM_REGISTERS)) : 0;
localparam int RESULT_WIDTH = OPERAND_CONFIG_WIDTH + TAG_WIDTH;
localparam int DERIVED_INSTRUCTION_WIDTH =
    1 + TAG_WIDTH
    + ((NUM_FU_TYPES > 1) ? $clog2(NUM_FU_TYPES) : 0)
    + NUM_INPUTS * OPERAND_CONFIG_WIDTH
    + NUM_OUTPUTS * RESULT_WIDTH;

initial begin
    assert (INSTRUCTION_WIDTH == DERIVED_INSTRUCTION_WIDTH)
      else $fatal(1, "INSTRUCTION_WIDTH must match derived temporal_pe formula");
end
```

#### fabric_switch.sv

```systemverilog
module fabric_switch #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    localparam int NUM_CONNECTED = $countones(CONNECTIVITY)  // Derived K in spec
) (
    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration: one bit per connected position in CONNECTIVITY
    // Bit order matches row-major scan of CONNECTIVITY (output then input)
    // A 1 enables the corresponding connection, 0 disables it
    input  logic [NUM_CONNECTED-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

**Config bit width:** `K` bits, where `K = $countones(CONNECTIVITY)` (number of connected positions). See [spec-fabric-switch.md](./spec-fabric-switch.md).
`fabric_switch` is combinational; it does not depend on `clk`/`rst_n`.

#### fabric_temporal_sw.sv

```systemverilog
module fabric_temporal_sw #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_ROUTE_TABLE = 8,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    localparam int NUM_CONNECTED = $countones(CONNECTIVITY),
    localparam int SLOT_WIDTH = 1 + TAG_WIDTH + NUM_CONNECTED
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface
    input  logic [NUM_ROUTE_TABLE-1:0][SLOT_WIDTH-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);

initial begin
    assert (SLOT_WIDTH == (1 + TAG_WIDTH + NUM_CONNECTED))
        else $fatal(1, "SLOT_WIDTH must equal 1 + TAG_WIDTH + NUM_CONNECTED");
end
```

`SLOT_WIDTH` is a derived quantity and must not be overridden. The exporter
must emit `CONNECTIVITY` consistently with the config_mem packer; the assertion
is a defensive check.

#### fabric_memory.sv

```systemverilog
module fabric_memory #(
    parameter int LD_COUNT = 1,
    parameter int ST_COUNT = 1,
    parameter int DATA_WIDTH = 32,
    parameter int ADDR_WIDTH = 32,
    parameter int TAG_WIDTH = 0,       // 0 for single-port (native)
    parameter int LSQ_DEPTH = 4,
    parameter bit PRIVATE = 1,
    parameter int MEM_DEPTH = 256      // Number of elements
) (
    input  logic clk,
    input  logic rst_n,

    // Load ports
    input  logic [LD_COUNT-1:0] ld_addr_valid,
    output logic [LD_COUNT-1:0] ld_addr_ready,
    input  logic [LD_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] ld_addr_data,

    output logic [LD_COUNT-1:0] ld_data_valid,
    input  logic [LD_COUNT-1:0] ld_data_ready,
    output logic [LD_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] ld_data_data,

    output logic [LD_COUNT-1:0] ld_done_valid,
    input  logic [LD_COUNT-1:0] ld_done_ready,

    // Store ports
    input  logic [ST_COUNT-1:0] st_addr_valid,
    output logic [ST_COUNT-1:0] st_addr_ready,
    input  logic [ST_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] st_addr_data,

    input  logic [ST_COUNT-1:0] st_data_valid,
    output logic [ST_COUNT-1:0] st_data_ready,
    input  logic [ST_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] st_data_data,

    output logic [ST_COUNT-1:0] st_done_valid,
    input  logic [ST_COUNT-1:0] st_done_ready,

    // Memory export (when PRIVATE = 0)
    // Directly connected to module output memref port

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_extmemory.sv

```systemverilog
module fabric_extmemory #(
    parameter int LD_COUNT = 1,
    parameter int ST_COUNT = 1,
    parameter int DATA_WIDTH = 32,
    parameter int ADDR_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int LSQ_DEPTH = 4
) (
    input  logic clk,
    input  logic rst_n,

    // External memory interface (AXI Master)
    // ... AXI master signals for external memory access

    // Load ports (same as fabric_memory)
    input  logic [LD_COUNT-1:0] ld_addr_valid,
    output logic [LD_COUNT-1:0] ld_addr_ready,
    input  logic [LD_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] ld_addr_data,

    output logic [LD_COUNT-1:0] ld_data_valid,
    input  logic [LD_COUNT-1:0] ld_data_ready,
    output logic [LD_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] ld_data_data,

    output logic [LD_COUNT-1:0] ld_done_valid,
    input  logic [LD_COUNT-1:0] ld_done_ready,

    // Store ports (same as fabric_memory)
    input  logic [ST_COUNT-1:0] st_addr_valid,
    output logic [ST_COUNT-1:0] st_addr_ready,
    input  logic [ST_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] st_addr_data,

    input  logic [ST_COUNT-1:0] st_data_valid,
    output logic [ST_COUNT-1:0] st_data_ready,
    input  logic [ST_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] st_data_data,

    output logic [ST_COUNT-1:0] st_done_valid,
    input  logic [ST_COUNT-1:0] st_done_ready,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_add_tag.sv

```systemverilog
module fabric_add_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4
    // CONFIG_WIDTH = TAG_WIDTH (the tag value to attach)
) (
    // Input: native value
    input  logic                          in_valid,
    output logic                          in_ready,
    input  logic [DATA_WIDTH-1:0]         in_data,

    // Output: tagged value
    output logic                          out_valid,
    input  logic                          out_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration: tag value
    input  logic [TAG_WIDTH-1:0]          cfg_tag
);
```

#### fabric_map_tag.sv

```systemverilog
module fabric_map_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int IN_TAG_WIDTH = 4,
    parameter int OUT_TAG_WIDTH = 4,
    parameter int TABLE_SIZE = 16
    // CONFIG_WIDTH = TABLE_SIZE * (1 + IN_TAG_WIDTH + OUT_TAG_WIDTH)
) (
    // Input: tagged value with input tag type
    input  logic                                    in_valid,
    output logic                                    in_ready,
    input  logic [DATA_WIDTH+IN_TAG_WIDTH-1:0]      in_data,

    // Output: tagged value with output tag type
    output logic                                    out_valid,
    input  logic                                    out_ready,
    output logic [DATA_WIDTH+OUT_TAG_WIDTH-1:0]     out_data,

    // Configuration: mapping table
    input  logic [TABLE_SIZE*(1+IN_TAG_WIDTH+OUT_TAG_WIDTH)-1:0] cfg_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_del_tag.sv

```systemverilog
module fabric_del_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4
) (
    // Input: tagged value
    input  logic                          in_valid,
    output logic                          in_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    // Output: native value (tag stripped)
    output logic                          out_valid,
    input  logic                          out_ready,
    output logic [DATA_WIDTH-1:0]         out_data
);
```

`fabric_add_tag` and `fabric_del_tag` intentionally do not expose
`error_valid/error_code` ports. They are unconditional combinational data
transformations with no runtime failure mode. `fabric_map_tag` keeps error
ports because table matching can fail at runtime/configuration time.

## config_mem Design

Shared config_mem semantics (address allocation, `CONFIG_WIDTH` derivation,
bit packing, and alignment) are defined authoritatively in
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md).

This document only specifies the SystemVerilog backend surface:

- Storage form: 32-bit register array (`logic [31:0] config_mem[...]`)
- Transport: AXI4-Lite slave interface
- Software-visible constants: generated `<module>_addr.h`

### AXI-Lite Interface

The config_mem controller implements a standard AXI4-Lite slave interface:

**Address decoding:**
- Write: `cfg_awaddr[ADDR_WIDTH-1:2]` selects word index
- Read: `cfg_araddr[ADDR_WIDTH-1:2]` selects word index
- Byte lanes (`cfg_wstrb`) are supported for partial writes

**Timing:**
- Single-cycle read latency (registered)
- Single-cycle write (combinational address phase, registered data)

**Error responses:**
- OKAY (2'b00): Valid access within config_mem range
- SLVERR (2'b10): Address out of range

## C Header Generation

The `exportSV()` function generates a C header file (`<module>_addr.h`)
containing address definitions:

```c
#ifndef MY_CGRA_ADDR_H
#define MY_CGRA_ADDR_H

// Config memory total size
#define MY_CGRA_CONFIG_MEM_DEPTH 5
#define MY_CGRA_CONFIG_MEM_BYTES 20

// Node base addresses (byte offsets)
#define MY_CGRA_NODE_0_ADDR 0x00
#define MY_CGRA_NODE_0_WORDS 2
#define MY_CGRA_NODE_3_ADDR 0x08
#define MY_CGRA_NODE_3_WORDS 1
#define MY_CGRA_NODE_7_ADDR 0x0C
#define MY_CGRA_NODE_7_WORDS 2

// Bit field definitions for node_0 (temporal_pe, 42 bits)
// instruction_mem bits [31:0] in word 0
// instruction_mem bits [41:32] in word 1 [9:0]
#define MY_CGRA_NODE_0_INSTR_WORD0_MASK 0xFFFFFFFF
#define MY_CGRA_NODE_0_INSTR_WORD1_MASK 0x000003FF
#define MY_CGRA_NODE_0_INSTR_WORD1_SHIFT 32

// ... similar definitions for other nodes

#endif // MY_CGRA_ADDR_H
```

## Configuration Bit Width Formulas

`CONFIG_WIDTH` formulas and field packing are defined authoritatively in
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md). Operation-specific
semantics remain in their corresponding `spec-fabric-*.md` documents.

## Streaming Interface Conventions

All streaming connections use the valid/ready handshake protocol defined in
[spec-adg.md](./spec-adg.md). See the "Streaming Handshake Protocol" section
in that document for the authoritative protocol rules.

The SystemVerilog interface definition:

```systemverilog
interface fabric_stream #(parameter WIDTH = 32);
    logic             valid;
    logic             ready;
    logic [WIDTH-1:0] data;

    modport source (output valid, data, input ready);
    modport sink   (input valid, data, output ready);
endinterface
```

This interface is defined in `fabric_common.svh` in the generated library set;
it is not emitted as a standalone `fabric_stream.sv` file.

## Error Reporting

Modules with runtime/configuration failure modes propagate errors upward
through `error_valid` and `error_code` signals. Error codes and their semantics
are defined in [spec-fabric-error.md](./spec-fabric-error.md). The top-level
module aggregates errors using priority encoding (lower code = higher
priority). The first error is latched until reset.

`fabric_add_tag` and `fabric_del_tag` are exception paths: they do not expose
error ports because they have no runtime failure mode.

## Synthesis Considerations

### Clock Domain

The entire design operates in a single clock domain. Clock domain crossing for
external interfaces (e.g., AXI-Lite from a different domain) must be handled
externally.

### Reset

Synchronous reset (active low) is used throughout:

```systemverilog
always_ff @(posedge clk) begin
    if (!rst_n) begin
        // Reset logic
    end else begin
        // Normal operation
    end
end
```

### Resource Optimization

The parameterized modules are designed for efficient synthesis:

- Unused features are constant-propagated away
- Configuration bits with tied zeros are optimized out
- Connectivity tables eliminate unconnected mux inputs

### Timing Constraints

The generated design targets the following:

- Single-cycle configuration write
- Single-cycle streaming transfer (for enabled routes)
- Tag matching is combinational within temporal modules

For high-frequency targets, users may need to add pipeline registers at module
boundaries.

## Verification Support

The generated RTL includes:

- Assertions for protocol compliance (valid/ready rules)
- Coverage points for configuration coverage
- Error injection hooks for fault simulation

Assertions are gated by `FABRIC_ASSERTIONS_ON` define.

## Related Documents

- [spec-adg.md](./spec-adg.md): ADG overall design
- [spec-adg-api.md](./spec-adg-api.md): ADGBuilder API reference
- [spec-adg-tools.md](./spec-adg-tools.md): Simulation tools and waveform formats
- [spec-adg-sysc.md](./spec-adg-sysc.md): SystemC generation specification
- [spec-fabric.md](./spec-fabric.md): Fabric MLIR dialect specification
- [spec-fabric-config_mem.md](./spec-fabric-config_mem.md): Authoritative config_mem rules
- [spec-fabric-error.md](./spec-fabric-error.md): Error code definitions
