# ADG SystemVerilog Generation Specification

## Overview

This document specifies the SystemVerilog output format generated by
`ADGBuilder::exportSV()`. The output is a hierarchical RTL design consisting of
parameterized modules that can be synthesized for FPGA or ASIC targets.

For the overall ADG design, see [spec-adg.md](./spec-adg.md).
For the builder API, see [spec-adg-api.md](./spec-adg-api.md).
For simulation tools and waveform formats, see [spec-adg-tools.md](./spec-adg-tools.md).

## File Organization

### Loom Source (Implementation)

The export implementation and parameterized templates are part of the Loom
source tree:

```
include/loom/Hardware/SystemVerilog/
  # Parameterized module templates (used by exporter, NOT referenced by output)

lib/loom/Hardware/SystemVerilog/
  ADGExportSV.cpp        # Export implementation
```

### Generated Output (Self-Contained)

**IMPORTANT:** The exported output is completely self-contained. It does not
reference or depend on any files in the Loom installation. All required files
are either generated or copied into the output directory.

Given `exportSV(directory)` with module name `my_cgra`, the following files are
generated:

```
<directory>/
  my_cgra_top.sv           # Top-level module with all instantiations
  my_cgra_config.sv        # config_mem controller with AXI-Lite interface
  my_cgra_addr.h           # C header with address definitions
  lib/                     # Library modules (copied from Loom templates)
    fabric_pe.sv           # Parameterized PE module
    fabric_temporal_pe.sv  # Parameterized temporal PE module
    fabric_switch.sv       # Parameterized switch module
    fabric_temporal_sw.sv  # Parameterized temporal switch module
    fabric_memory.sv       # Parameterized memory module
    fabric_extmemory.sv    # Parameterized external memory module
    fabric_add_tag.sv      # Parameterized add_tag module
    fabric_map_tag.sv      # Parameterized map_tag module
    fabric_del_tag.sv      # Parameterized del_tag module
    fabric_common.svh      # Common definitions and interfaces
```

The entire `<directory>/` can be moved, archived, or shared without requiring
access to the Loom installation.

## Module Hierarchy

### Top-Level Module

The top-level module (`my_cgra_top.sv`) contains:

1. Module interface matching `fabric.module` ports
2. config_mem controller instantiation
3. All fabric operation instantiations
4. Internal signal wiring

**Interface structure:**

```systemverilog
module my_cgra_top #(
    parameter DATA_WIDTH = 32,
    parameter TAG_WIDTH = 4,
    parameter ADDR_WIDTH = 32
) (
    // Clock and reset
    input  logic clk,
    input  logic rst_n,

    // AXI-Lite configuration interface
    input  logic [ADDR_WIDTH-1:0] cfg_awaddr,
    input  logic                  cfg_awvalid,
    output logic                  cfg_awready,
    input  logic [31:0]           cfg_wdata,
    input  logic                  cfg_wvalid,
    output logic                  cfg_wready,
    output logic [1:0]            cfg_bresp,
    output logic                  cfg_bvalid,
    input  logic                  cfg_bready,
    input  logic [ADDR_WIDTH-1:0] cfg_araddr,
    input  logic                  cfg_arvalid,
    output logic                  cfg_arready,
    output logic [31:0]           cfg_rdata,
    output logic [1:0]            cfg_rresp,
    output logic                  cfg_rvalid,
    input  logic                  cfg_rready,

    // Memref ports (AXI Master interfaces)
    // ... generated based on fabric.module interface

    // Native streaming ports (AXI-Stream interfaces)
    // ... generated based on fabric.module interface

    // Tagged streaming ports (AXI-Stream with sideband)
    // ... generated based on fabric.module interface

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

### Parameterized Fabric Modules

Each fabric operation type has a corresponding parameterized SystemVerilog
module. Parameters correspond to hardware attributes from the Fabric MLIR spec.

#### fabric_pe.sv

```systemverilog
module fabric_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,      // 0 means native interface
    parameter int LATENCY_MIN = 1,
    parameter int LATENCY_TYP = 1,
    parameter int LATENCY_MAX = 1,
    parameter int INTERVAL_MIN = 1,
    parameter int INTERVAL_TYP = 1,
    parameter int INTERVAL_MAX = 1
) (
    input  logic clk,
    input  logic rst_n,

    // Input ports (valid/ready/data)
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    // Output ports (valid/ready/data)
    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration (for output_tag when tagged)
    input  logic [NUM_OUTPUTS-1:0][TAG_WIDTH-1:0] cfg_output_tag
);
```

#### fabric_temporal_pe.sv

```systemverilog
module fabric_temporal_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_REGISTER = 4,
    parameter int NUM_INSTRUCTION = 16,
    parameter int NUM_INSTANCE = 2,
    parameter int NUM_FU_TYPES = 2,
    parameter int INSTRUCTION_WIDTH = 64,
    // Operand buffer mode parameters
    parameter bit ENABLE_SHARED_OPERAND_BUFFER = 0,  // 0=Mode A, 1=Mode B
    parameter int OPERAND_BUFFER_SIZE = 0            // Mode B only, range [1,8192]
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface (instruction_mem only, no operand buffers)
    input  logic [NUM_INSTRUCTION-1:0][INSTRUCTION_WIDTH-1:0] cfg_instruction_mem,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

**Note:** The operand buffer is internal to the module and not part of
`cfg_instruction_mem`. Mode A uses `NUM_INSTRUCTION * NUM_INPUTS * (1 + DATA_WIDTH)`
bits internally. Mode B uses `OPERAND_BUFFER_SIZE` entries with per-tag FIFO semantics.

#### fabric_switch.sv

```systemverilog
module fabric_switch #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    parameter int NUM_CONNECTED = $countones(CONNECTIVITY)  // K in spec
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration: one bit per connected position in CONNECTIVITY
    // Bit order matches row-major scan of CONNECTIVITY (output then input)
    // A 1 enables the corresponding connection, 0 disables it
    input  logic [NUM_CONNECTED-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_temporal_sw.sv

```systemverilog
module fabric_temporal_sw #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_ROUTE_TABLE = 8,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    parameter int SLOT_WIDTH = 16
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface
    input  logic [NUM_ROUTE_TABLE-1:0][SLOT_WIDTH-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

## config_mem Design

### Purpose

The `config_mem` is a register array that holds all runtime configuration for
the accelerator. It provides:

- Unified memory-mapped access via AXI-Lite
- Simple software programming model
- Deterministic configuration sequence

### Register Array Structure

The config_mem is organized as an array of 32-bit registers:

```systemverilog
logic [31:0] config_mem [0:CONFIG_MEM_DEPTH-1];
```

Each configurable operation occupies a contiguous range of 32-bit words.
Operations are isolated; no two operations share a word.

### Address Allocation Rules

Addresses are allocated sequentially based on MLIR operation order:

1. Traverse operations in `fabric.module` in definition order
2. For each configurable operation:
   a. Calculate required bits (see formulas below)
   b. Align to next 32-bit word boundary
   c. Allocate ceiling(bits/32) words
   d. Record base address and bit layout
3. Total depth = last address + 1

**Example allocation:**

| Node | Type | Config Bits | Start Word | Words | End Word |
|------|------|-------------|------------|-------|----------|
| node_0 | temporal_pe | 42 | 0 | 2 | 1 |
| node_3 | switch | 17 | 2 | 1 | 2 |
| node_7 | temporal_sw | 33 | 3 | 2 | 4 |

Total config_mem depth: 5 words (20 bytes)

### Bit Layout Within Words

Configuration bits are packed starting from the LSB of each word:

```
Word N:   [31:bits_used] = 0 (tied low)
          [bits_used-1:0] = config data

Word N+1: [31:remaining] = 0 (tied low)
          [remaining-1:0] = overflow config data
```

For multi-word configurations, bits flow from LSB of word 0 to MSB of word 0,
then LSB of word 1, and so on.

### Unused Bits

Unused bits within each word are tied to constant zero. These bits:

- Are readable (always return 0)
- Are writable (writes are ignored)
- Will be optimized away by synthesis tools

### AXI-Lite Interface

The config_mem controller implements a standard AXI4-Lite slave interface:

**Address decoding:**
- Write: `cfg_awaddr[ADDR_WIDTH-1:2]` selects word index
- Read: `cfg_araddr[ADDR_WIDTH-1:2]` selects word index
- Byte lanes (`cfg_wstrb`) are supported for partial writes

**Timing:**
- Single-cycle read latency (registered)
- Single-cycle write (combinational address phase, registered data)

**Error responses:**
- OKAY (2'b00): Valid access within config_mem range
- SLVERR (2'b10): Address out of range

### Configuration Sequence

Software configures the accelerator by:

1. Assert reset
2. Write all config_mem words via AXI-Lite
3. De-assert reset
4. Begin dataflow execution

Partial reconfiguration (updating some nodes while others execute) is not
supported in the base design.

## C Header Generation

The `exportSV()` function generates a C header file (`<module>_addr.h`)
containing address definitions:

```c
#ifndef MY_CGRA_ADDR_H
#define MY_CGRA_ADDR_H

// Config memory total size
#define MY_CGRA_CONFIG_MEM_DEPTH 5
#define MY_CGRA_CONFIG_MEM_BYTES 20

// Node base addresses (byte offsets)
#define MY_CGRA_NODE_0_ADDR 0x00
#define MY_CGRA_NODE_0_WORDS 2
#define MY_CGRA_NODE_3_ADDR 0x08
#define MY_CGRA_NODE_3_WORDS 1
#define MY_CGRA_NODE_7_ADDR 0x0C
#define MY_CGRA_NODE_7_WORDS 2

// Bit field definitions for node_0 (temporal_pe, 42 bits)
// instruction_mem bits [31:0] in word 0
// instruction_mem bits [41:32] in word 1 [9:0]
#define MY_CGRA_NODE_0_INSTR_WORD0_MASK 0xFFFFFFFF
#define MY_CGRA_NODE_0_INSTR_WORD1_MASK 0x000003FF
#define MY_CGRA_NODE_0_INSTR_WORD1_SHIFT 32

// ... similar definitions for other nodes

#endif // MY_CGRA_ADDR_H
```

## Configuration Bit Width Formulas

For detailed bit width formulas, see the authoritative Fabric specification
documents:

- [spec-fabric-pe.md](./spec-fabric-pe.md): PE configuration
- [spec-fabric-tag.md](./spec-fabric-tag.md): Tag operations
- [spec-fabric-switch.md](./spec-fabric-switch.md): Switch configuration
- [spec-fabric-temporal_pe.md](./spec-fabric-temporal_pe.md): Temporal PE instruction memory
- [spec-fabric-temporal_sw.md](./spec-fabric-temporal_sw.md): Temporal switch route tables

### Quick Reference

| Operation | Formula | Notes |
|-----------|---------|-------|
| `fabric.pe` (tagged) | N * M | N outputs, M tag bits |
| `fabric.pe` (constant, native) | bitwidth(value) | Constant value only |
| `fabric.pe` (constant, tagged) | bitwidth(value) + M | Value + tag, packed continuously |
| `fabric.add_tag` | M | Tag width |
| `fabric.map_tag` | table_size * (1 + M_in + M_out) | Per-entry format |
| `fabric.switch` | K | K = connected positions |
| `fabric.temporal_pe` | See [spec-fabric-temporal_pe.md](./spec-fabric-temporal_pe.md) | Complex formula |
| `fabric.temporal_sw` | num_route_table * (1 + M + K) | Per-slot format |

**Note:** Fields within a module's config_mem allocation are packed continuously
(LSB-first). The 32-bit word alignment applies to the entire module's total
config bits, not individual fields.

## Streaming Interface Conventions

All streaming connections use a valid/ready handshake protocol:

```systemverilog
interface fabric_stream #(parameter WIDTH = 32);
    logic             valid;
    logic             ready;
    logic [WIDTH-1:0] data;

    modport source (output valid, data, input ready);
    modport sink   (input valid, data, output ready);
endinterface
```

**Handshake rules:**
- Transfer occurs when `valid && ready` on rising clock edge
- `valid` must not depend on `ready`
- `ready` may depend on `valid`
- Once asserted, `valid` must remain high until transfer

For tagged interfaces, the data signal contains both value and tag:

```
data[TAG_WIDTH+DATA_WIDTH-1:DATA_WIDTH] = tag
data[DATA_WIDTH-1:0] = value
```

## Error Reporting

Each module propagates errors upward through error signals:

```systemverilog
output logic        error_valid;
output logic [15:0] error_code;
```

Error codes use the values defined in
[spec-fabric-error.md](./spec-fabric-error.md):

- CFG_ errors (0-7): Configuration errors detected after programming
- RT_ errors (256+): Runtime execution errors

The top-level module aggregates errors using priority encoding (lower code =
higher priority). The first error is latched until reset.

## Synthesis Considerations

### Clock Domain

The entire design operates in a single clock domain. Clock domain crossing for
external interfaces (e.g., AXI-Lite from a different domain) must be handled
externally.

### Reset

Synchronous reset (active low) is used throughout:

```systemverilog
always_ff @(posedge clk) begin
    if (!rst_n) begin
        // Reset logic
    end else begin
        // Normal operation
    end
end
```

### Resource Optimization

The parameterized modules are designed for efficient synthesis:

- Unused features are constant-propagated away
- Configuration bits with tied zeros are optimized out
- Connectivity tables eliminate unconnected mux inputs

### Timing Constraints

The generated design targets the following:

- Single-cycle configuration write
- Single-cycle streaming transfer (for enabled routes)
- Tag matching is combinational within temporal modules

For high-frequency targets, users may need to add pipeline registers at module
boundaries.

## Verification Support

The generated RTL includes:

- Assertions for protocol compliance (valid/ready rules)
- Coverage points for configuration coverage
- Error injection hooks for fault simulation

Assertions are gated by `FABRIC_ASSERTIONS_ON` define.
