# ADG SystemVerilog Generation Specification

## Overview

This document specifies the SystemVerilog output format generated by
`ADGBuilder::exportSV()`. The output is a hierarchical RTL design consisting of
parameterized modules that can be synthesized for FPGA or ASIC targets.

For the overall ADG design, see [spec-adg.md](./spec-adg.md).
For the builder API, see [spec-adg-api.md](./spec-adg-api.md).
For simulation tools and waveform formats, see [spec-adg-tools.md](./spec-adg-tools.md).

## File Organization

### Loom Source (Implementation)

The export implementation and parameterized templates are part of the Loom
source tree:

```
include/loom/Hardware/SystemVerilog/
  # Parameterized module templates (used by exporter, NOT referenced by output)

lib/loom/Hardware/SystemVerilog/
  ADGExportSV.cpp        # Export implementation
```

### Generated Output (Self-Contained)

**IMPORTANT:** The exported output is completely self-contained. It does not
reference or depend on any files in the Loom installation. All required files
are either generated or copied into the output directory.

Given `exportSV(directory)` with module name `my_cgra`, the following files are
generated:

```
<directory>/
  my_cgra_top.sv           # Top-level module with all instantiations
  my_cgra_config.sv        # config_mem controller with AXI-Lite interface
  my_cgra_addr.h           # C header with address definitions
  lib/                     # Library modules (copied from Loom templates)
    fabric_pe.sv           # Parameterized PE module
    fabric_temporal_pe.sv  # Parameterized temporal PE module
    fabric_switch.sv       # Parameterized switch module
    fabric_temporal_sw.sv  # Parameterized temporal switch module
    fabric_memory.sv       # Parameterized memory module
    fabric_extmemory.sv    # Parameterized external memory module
    fabric_add_tag.sv      # Parameterized add_tag module
    fabric_map_tag.sv      # Parameterized map_tag module
    fabric_del_tag.sv      # Parameterized del_tag module
    fabric_common.svh      # Common definitions and interfaces
```

The entire `<directory>/` can be moved, archived, or shared without requiring
access to the Loom installation.

## Module Hierarchy

### Top-Level Module

The top-level module (`my_cgra_top.sv`) contains:

1. Module interface matching `fabric.module` ports
2. config_mem controller instantiation
3. All fabric operation instantiations
4. Internal signal wiring

**Interface structure:**

```systemverilog
module my_cgra_top #(
    parameter DATA_WIDTH = 32,
    parameter TAG_WIDTH = 4,
    parameter ADDR_WIDTH = 32
) (
    // Clock and reset
    input  logic clk,
    input  logic rst_n,

    // AXI-Lite configuration interface
    input  logic [ADDR_WIDTH-1:0] cfg_awaddr,
    input  logic                  cfg_awvalid,
    output logic                  cfg_awready,
    input  logic [31:0]           cfg_wdata,
    input  logic                  cfg_wvalid,
    output logic                  cfg_wready,
    output logic [1:0]            cfg_bresp,
    output logic                  cfg_bvalid,
    input  logic                  cfg_bready,
    input  logic [ADDR_WIDTH-1:0] cfg_araddr,
    input  logic                  cfg_arvalid,
    output logic                  cfg_arready,
    output logic [31:0]           cfg_rdata,
    output logic [1:0]            cfg_rresp,
    output logic                  cfg_rvalid,
    input  logic                  cfg_rready,

    // Memref ports (AXI Master interfaces)
    // ... generated based on fabric.module interface

    // Native streaming ports (AXI-Stream interfaces)
    // ... generated based on fabric.module interface

    // Tagged streaming ports (AXI-Stream with sideband)
    // ... generated based on fabric.module interface

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

### Parameterized Fabric Modules

Each fabric operation type has a corresponding parameterized SystemVerilog
module. Parameters correspond to hardware attributes from the Fabric MLIR spec.

#### fabric_pe.sv

```systemverilog
module fabric_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int IN_DATA_WIDTH [NUM_INPUTS] = '{default: 32},
    parameter int OUT_DATA_WIDTH [NUM_OUTPUTS] = '{default: 32},
    parameter int TAG_WIDTH = 0,      // 0 means native interface
    parameter int LATENCY_MIN = 1,
    parameter int LATENCY_TYP = 1,
    parameter int LATENCY_MAX = 1,
    parameter int INTERVAL_MIN = 1,
    parameter int INTERVAL_TYP = 1,
    parameter int INTERVAL_MAX = 1,
    // CONFIG_WIDTH: derived, not overridable
    localparam int CONFIG_WIDTH = (TAG_WIDTH > 0) ? NUM_OUTPUTS * TAG_WIDTH : 0
) (
    input  logic clk,
    input  logic rst_n,

    // Input ports (valid/ready per port)
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,

    // Output ports (valid/ready per port)
    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,

    // Generic configuration data (derived CONFIG_WIDTH)
    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);

// Per-port data wires with individual widths.
// Accessed as gen_in[i].data and gen_out[o].data.
generate
    for (genvar i = 0; i < NUM_INPUTS; i++) begin : gen_in
        wire [IN_DATA_WIDTH[i]+TAG_WIDTH-1:0] data;
    end
    for (genvar o = 0; o < NUM_OUTPUTS; o++) begin : gen_out
        wire [OUT_DATA_WIDTH[o]+TAG_WIDTH-1:0] data;
    end
endgenerate
```

#### Constant PE Variant

A constant PE contains exactly one `handshake.constant` in its body. The
constant value is runtime configurable via config_mem.

```systemverilog
module fabric_pe_constant #(
    parameter int NUM_OUTPUTS = 1,
    parameter int OUT_DATA_WIDTH [NUM_OUTPUTS] = '{default: 32},
    parameter int TAG_WIDTH = 0,
    parameter int LATENCY_MIN = 0,
    parameter int LATENCY_TYP = 0,
    parameter int LATENCY_MAX = 0,
    parameter int INTERVAL_MIN = 1,
    parameter int INTERVAL_TYP = 1,
    parameter int INTERVAL_MAX = 1,
    // CONFIG_WIDTH: derived
    //   Native:  bitwidth(constant_value)
    //   Tagged:  bitwidth(constant_value) + TAG_WIDTH
    localparam int CONST_WIDTH = OUT_DATA_WIDTH[0],
    localparam int CONFIG_WIDTH = (TAG_WIDTH > 0)
        ? CONST_WIDTH + TAG_WIDTH : CONST_WIDTH
) (
    input  logic clk,
    input  logic rst_n,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);

generate
    for (genvar o = 0; o < NUM_OUTPUTS; o++) begin : gen_out
        wire [OUT_DATA_WIDTH[o]+TAG_WIDTH-1:0] data;
    end
endgenerate
```

No input ports: the constant value comes from `cfg_data`. See
[spec-fabric-pe.md](./spec-fabric-pe.md) for constant exclusivity rules.

#### Load PE Variant

A load PE contains exactly one `handshake.load` in its body.

```systemverilog
module fabric_pe_load #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    parameter int LQ_DEPTH = 0,       // Required when HARDWARE_TYPE = 1
    // CONFIG_WIDTH: derived
    //   TagOverwrite (tagged):  TAG_WIDTH (output_tag)
    //   TagOverwrite (native):  0
    //   TagTransparent:         0 (no output_tag)
    localparam int CONFIG_WIDTH = (HARDWARE_TYPE == 0 && TAG_WIDTH > 0)
        ? TAG_WIDTH : 0
) (
    input  logic clk,
    input  logic rst_n,

    // From compute: address
    input  logic                          addr_valid,
    output logic                          addr_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] addr_data,

    // From memory: returned data
    input  logic                          mem_data_valid,
    output logic                          mem_data_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_data,

    // Control token
    input  logic                          ctrl_valid,
    output logic                          ctrl_ready,

    // To memory: address
    output logic                          mem_addr_valid,
    input  logic                          mem_addr_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_addr_data,

    // To compute: data
    output logic                          data_valid,
    input  logic                          data_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] data_out,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
(TagOverwrite vs TagTransparent) and port role definitions.

#### Store PE Variant

A store PE contains exactly one `handshake.store` in its body.

```systemverilog
module fabric_pe_store #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    parameter int SQ_DEPTH = 0,       // Required when HARDWARE_TYPE = 1
    localparam int CONFIG_WIDTH = (HARDWARE_TYPE == 0 && TAG_WIDTH > 0)
        ? TAG_WIDTH : 0
) (
    input  logic clk,
    input  logic rst_n,

    // From compute: address
    input  logic                          addr_valid,
    output logic                          addr_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] addr_data,

    // From compute: data
    input  logic                          data_valid,
    output logic                          data_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] data_in,

    // Control token
    input  logic                          ctrl_valid,
    output logic                          ctrl_ready,

    // To memory: address
    output logic                          mem_addr_valid,
    input  logic                          mem_addr_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_addr_data,

    // To memory: data
    output logic                          mem_data_valid,
    input  logic                          mem_data_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] mem_data_out,

    input  logic [CONFIG_WIDTH-1:0] cfg_data,

    output logic        error_valid,
    output logic [15:0] error_code
);
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
and port role definitions.

#### fabric_temporal_pe.sv

```systemverilog
module fabric_temporal_pe #(
    parameter int NUM_INPUTS = 2,
    parameter int NUM_OUTPUTS = 1,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_REGISTER = 4,
    parameter int NUM_INSTRUCTION = 16,
    parameter int NUM_INSTANCE = 2,
    parameter int NUM_FU_TYPES = 2,
    parameter int INSTRUCTION_WIDTH = 64,
    // Operand buffer mode parameters
    parameter bit ENABLE_SHARED_OPERAND_BUFFER = 0,  // 0=Mode A, 1=Mode B
    parameter int OPERAND_BUFFER_SIZE = 0            // Mode B only, range [1,8192]
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface (instruction_mem only, no operand buffers)
    input  logic [NUM_INSTRUCTION-1:0][INSTRUCTION_WIDTH-1:0] cfg_instruction_mem,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

**Note:** The operand buffer is internal to the module and not part of
`cfg_instruction_mem`. Mode A uses `NUM_INSTRUCTION * NUM_INPUTS * (1 + DATA_WIDTH)`
bits internally. Mode B uses `OPERAND_BUFFER_SIZE` entries with per-tag FIFO semantics.

#### fabric_switch.sv

```systemverilog
module fabric_switch #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    parameter int NUM_CONNECTED = $countones(CONNECTIVITY)  // K in spec
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration: one bit per connected position in CONNECTIVITY
    // Bit order matches row-major scan of CONNECTIVITY (output then input)
    // A 1 enables the corresponding connection, 0 disables it
    input  logic [NUM_CONNECTED-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

**Config bit width:** `K` bits, where `K = $countones(CONNECTIVITY)` (number of connected positions). See [spec-fabric-switch.md](./spec-fabric-switch.md).

#### fabric_temporal_sw.sv

```systemverilog
module fabric_temporal_sw #(
    parameter int NUM_INPUTS = 4,
    parameter int NUM_OUTPUTS = 4,
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4,
    parameter int NUM_ROUTE_TABLE = 8,
    parameter bit [NUM_OUTPUTS*NUM_INPUTS-1:0] CONNECTIVITY = '1,
    parameter int SLOT_WIDTH = 16
) (
    input  logic clk,
    input  logic rst_n,

    // Streaming ports
    input  logic [NUM_INPUTS-1:0]  in_valid,
    output logic [NUM_INPUTS-1:0]  in_ready,
    input  logic [NUM_INPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    output logic [NUM_OUTPUTS-1:0] out_valid,
    input  logic [NUM_OUTPUTS-1:0] out_ready,
    output logic [NUM_OUTPUTS-1:0][DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration memory interface
    input  logic [NUM_ROUTE_TABLE-1:0][SLOT_WIDTH-1:0] cfg_route_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_memory.sv

```systemverilog
module fabric_memory #(
    parameter int LD_COUNT = 1,
    parameter int ST_COUNT = 1,
    parameter int DATA_WIDTH = 32,
    parameter int ADDR_WIDTH = 32,
    parameter int TAG_WIDTH = 0,       // 0 for single-port (native)
    parameter int LSQ_DEPTH = 4,
    parameter bit PRIVATE = 1,
    parameter int MEM_DEPTH = 256      // Number of elements
) (
    input  logic clk,
    input  logic rst_n,

    // Load ports
    input  logic [LD_COUNT-1:0] ld_addr_valid,
    output logic [LD_COUNT-1:0] ld_addr_ready,
    input  logic [LD_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] ld_addr_data,

    output logic [LD_COUNT-1:0] ld_data_valid,
    input  logic [LD_COUNT-1:0] ld_data_ready,
    output logic [LD_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] ld_data_data,

    output logic [LD_COUNT-1:0] ld_done_valid,
    input  logic [LD_COUNT-1:0] ld_done_ready,

    // Store ports
    input  logic [ST_COUNT-1:0] st_addr_valid,
    output logic [ST_COUNT-1:0] st_addr_ready,
    input  logic [ST_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] st_addr_data,

    input  logic [ST_COUNT-1:0] st_data_valid,
    output logic [ST_COUNT-1:0] st_data_ready,
    input  logic [ST_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] st_data_data,

    output logic [ST_COUNT-1:0] st_done_valid,
    input  logic [ST_COUNT-1:0] st_done_ready,

    // Memory export (when PRIVATE = 0)
    // Directly connected to module output memref port

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_extmemory.sv

```systemverilog
module fabric_extmemory #(
    parameter int LD_COUNT = 1,
    parameter int ST_COUNT = 1,
    parameter int DATA_WIDTH = 32,
    parameter int ADDR_WIDTH = 32,
    parameter int TAG_WIDTH = 0,
    parameter int LSQ_DEPTH = 4
) (
    input  logic clk,
    input  logic rst_n,

    // External memory interface (AXI Master)
    // ... AXI master signals for external memory access

    // Load ports (same as fabric_memory)
    input  logic [LD_COUNT-1:0] ld_addr_valid,
    output logic [LD_COUNT-1:0] ld_addr_ready,
    input  logic [LD_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] ld_addr_data,

    output logic [LD_COUNT-1:0] ld_data_valid,
    input  logic [LD_COUNT-1:0] ld_data_ready,
    output logic [LD_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] ld_data_data,

    output logic [LD_COUNT-1:0] ld_done_valid,
    input  logic [LD_COUNT-1:0] ld_done_ready,

    // Store ports (same as fabric_memory)
    input  logic [ST_COUNT-1:0] st_addr_valid,
    output logic [ST_COUNT-1:0] st_addr_ready,
    input  logic [ST_COUNT-1:0][ADDR_WIDTH+TAG_WIDTH-1:0] st_addr_data,

    input  logic [ST_COUNT-1:0] st_data_valid,
    output logic [ST_COUNT-1:0] st_data_ready,
    input  logic [ST_COUNT-1:0][DATA_WIDTH+TAG_WIDTH-1:0] st_data_data,

    output logic [ST_COUNT-1:0] st_done_valid,
    input  logic [ST_COUNT-1:0] st_done_ready,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_add_tag.sv

```systemverilog
module fabric_add_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4
    // CONFIG_WIDTH = TAG_WIDTH (the tag value to attach)
) (
    input  logic clk,
    input  logic rst_n,

    // Input: native value
    input  logic                          in_valid,
    output logic                          in_ready,
    input  logic [DATA_WIDTH-1:0]         in_data,

    // Output: tagged value
    output logic                          out_valid,
    input  logic                          out_ready,
    output logic [DATA_WIDTH+TAG_WIDTH-1:0] out_data,

    // Configuration: tag value
    input  logic [TAG_WIDTH-1:0]          cfg_tag
);
```

#### fabric_map_tag.sv

```systemverilog
module fabric_map_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int IN_TAG_WIDTH = 4,
    parameter int OUT_TAG_WIDTH = 4,
    parameter int TABLE_SIZE = 16
    // CONFIG_WIDTH = TABLE_SIZE * (1 + IN_TAG_WIDTH + OUT_TAG_WIDTH)
) (
    input  logic clk,
    input  logic rst_n,

    // Input: tagged value with input tag type
    input  logic                                    in_valid,
    output logic                                    in_ready,
    input  logic [DATA_WIDTH+IN_TAG_WIDTH-1:0]      in_data,

    // Output: tagged value with output tag type
    output logic                                    out_valid,
    input  logic                                    out_ready,
    output logic [DATA_WIDTH+OUT_TAG_WIDTH-1:0]     out_data,

    // Configuration: mapping table
    input  logic [TABLE_SIZE*(1+IN_TAG_WIDTH+OUT_TAG_WIDTH)-1:0] cfg_table,

    // Error reporting
    output logic        error_valid,
    output logic [15:0] error_code
);
```

#### fabric_del_tag.sv

```systemverilog
module fabric_del_tag #(
    parameter int DATA_WIDTH = 32,
    parameter int TAG_WIDTH = 4
) (
    // Input: tagged value
    input  logic                          in_valid,
    output logic                          in_ready,
    input  logic [DATA_WIDTH+TAG_WIDTH-1:0] in_data,

    // Output: native value (tag stripped)
    output logic                          out_valid,
    input  logic                          out_ready,
    output logic [DATA_WIDTH-1:0]         out_data
);
```

## config_mem Design

For the formal definition of config_mem (word width, depth calculation,
CONFIG_WIDTH derivation), see
[spec-fabric-config_mem.md](../temp/spec-fabric-config_mem.md).

### Purpose

The `config_mem` is a register array that holds all runtime configuration for
the accelerator. It provides:

- Unified memory-mapped access via AXI-Lite
- Simple software programming model
- Deterministic configuration sequence

### Register Array Structure

The config_mem is organized as an array of 32-bit registers:

```systemverilog
logic [31:0] config_mem [0:CONFIG_MEM_DEPTH-1];
```

Each configurable operation occupies a contiguous range of 32-bit words.
Operations are isolated; no two operations share a word.

### Address Allocation Rules

Address allocation follows the authoritative rules defined in
[spec-adg.md](./spec-adg.md). See the "Address Allocation" section in that
document for the complete specification including allocation steps, alignment
rules, and isolation guarantees.

Total config_mem depth: 5 words (20 bytes)

### Bit Layout Within Words

Configuration bits are packed starting from the LSB of each word:

```
Word N:   [31:bits_used] = 0 (tied low)
          [bits_used-1:0] = config data

Word N+1: [31:remaining] = 0 (tied low)
          [remaining-1:0] = overflow config data
```

For multi-word configurations, bits flow from LSB of word 0 to MSB of word 0,
then LSB of word 1, and so on.

### Unused Bits

Unused bits within each word are tied to constant zero. These bits:

- Are readable (always return 0)
- Are writable (writes are ignored)
- Will be optimized away by synthesis tools

### AXI-Lite Interface

The config_mem controller implements a standard AXI4-Lite slave interface:

**Address decoding:**
- Write: `cfg_awaddr[ADDR_WIDTH-1:2]` selects word index
- Read: `cfg_araddr[ADDR_WIDTH-1:2]` selects word index
- Byte lanes (`cfg_wstrb`) are supported for partial writes

**Timing:**
- Single-cycle read latency (registered)
- Single-cycle write (combinational address phase, registered data)

**Error responses:**
- OKAY (2'b00): Valid access within config_mem range
- SLVERR (2'b10): Address out of range

### Configuration Sequence

Software configures the accelerator by:

1. Assert reset
2. Write all config_mem words via AXI-Lite
3. De-assert reset
4. Begin dataflow execution

Partial reconfiguration (updating some nodes while others execute) is not
supported in the base design.

## C Header Generation

The `exportSV()` function generates a C header file (`<module>_addr.h`)
containing address definitions:

```c
#ifndef MY_CGRA_ADDR_H
#define MY_CGRA_ADDR_H

// Config memory total size
#define MY_CGRA_CONFIG_MEM_DEPTH 5
#define MY_CGRA_CONFIG_MEM_BYTES 20

// Node base addresses (byte offsets)
#define MY_CGRA_NODE_0_ADDR 0x00
#define MY_CGRA_NODE_0_WORDS 2
#define MY_CGRA_NODE_3_ADDR 0x08
#define MY_CGRA_NODE_3_WORDS 1
#define MY_CGRA_NODE_7_ADDR 0x0C
#define MY_CGRA_NODE_7_WORDS 2

// Bit field definitions for node_0 (temporal_pe, 42 bits)
// instruction_mem bits [31:0] in word 0
// instruction_mem bits [41:32] in word 1 [9:0]
#define MY_CGRA_NODE_0_INSTR_WORD0_MASK 0xFFFFFFFF
#define MY_CGRA_NODE_0_INSTR_WORD1_MASK 0x000003FF
#define MY_CGRA_NODE_0_INSTR_WORD1_SHIFT 32

// ... similar definitions for other nodes

#endif // MY_CGRA_ADDR_H
```

## Configuration Bit Width Formulas

For detailed bit width formulas, see the authoritative Fabric specification
documents:

- [spec-fabric-pe.md](./spec-fabric-pe.md): PE configuration
- [spec-fabric-tag.md](./spec-fabric-tag.md): Tag operations
- [spec-fabric-switch.md](./spec-fabric-switch.md): Switch configuration
- [spec-fabric-temporal_pe.md](./spec-fabric-temporal_pe.md): Temporal PE instruction memory
- [spec-fabric-temporal_sw.md](./spec-fabric-temporal_sw.md): Temporal switch route tables

### Quick Reference

| Operation | Formula | Notes |
|-----------|---------|-------|
| `fabric.pe` (tagged) | N * M | N outputs, M tag bits |
| `fabric.pe` (constant, native) | bitwidth(value) | Constant value only |
| `fabric.pe` (constant, tagged) | bitwidth(value) + M | Value + tag, packed continuously |
| `fabric.add_tag` | M | Tag width |
| `fabric.map_tag` | table_size * (1 + M_in + M_out) | Per-entry format |
| `fabric.switch` | K | K = connected positions |
| `fabric.temporal_pe` | See [spec-fabric-temporal_pe.md](./spec-fabric-temporal_pe.md) | Complex formula |
| `fabric.temporal_sw` | num_route_table * (1 + M + K) | Per-slot format |

**Note:** Fields within a module's config_mem allocation are packed continuously
(LSB-first). The 32-bit word alignment applies to the entire module's total
config bits, not individual fields.

## Streaming Interface Conventions

All streaming connections use the valid/ready handshake protocol defined in
[spec-adg.md](./spec-adg.md). See the "Streaming Handshake Protocol" section
in that document for the authoritative protocol rules.

The SystemVerilog interface definition:

```systemverilog
interface fabric_stream #(parameter WIDTH = 32);
    logic             valid;
    logic             ready;
    logic [WIDTH-1:0] data;

    modport source (output valid, data, input ready);
    modport sink   (input valid, data, output ready);
endinterface
```

## Error Reporting

Each module propagates errors upward through `error_valid` and `error_code`
signals. Error codes and their semantics are defined in
[spec-fabric-error.md](./spec-fabric-error.md). The top-level module
aggregates errors using priority encoding (lower code = higher priority).
The first error is latched until reset.

## Synthesis Considerations

### Clock Domain

The entire design operates in a single clock domain. Clock domain crossing for
external interfaces (e.g., AXI-Lite from a different domain) must be handled
externally.

### Reset

Synchronous reset (active low) is used throughout:

```systemverilog
always_ff @(posedge clk) begin
    if (!rst_n) begin
        // Reset logic
    end else begin
        // Normal operation
    end
end
```

### Resource Optimization

The parameterized modules are designed for efficient synthesis:

- Unused features are constant-propagated away
- Configuration bits with tied zeros are optimized out
- Connectivity tables eliminate unconnected mux inputs

### Timing Constraints

The generated design targets the following:

- Single-cycle configuration write
- Single-cycle streaming transfer (for enabled routes)
- Tag matching is combinational within temporal modules

For high-frequency targets, users may need to add pipeline registers at module
boundaries.

## Verification Support

The generated RTL includes:

- Assertions for protocol compliance (valid/ready rules)
- Coverage points for configuration coverage
- Error injection hooks for fault simulation

Assertions are gated by `FABRIC_ASSERTIONS_ON` define.
