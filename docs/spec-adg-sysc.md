# ADG SystemC Generation Specification

## Overview

This document specifies the SystemC output format generated by
`ADGBuilder::exportSysC()`. The output is a cycle-accurate simulation model
using SystemC 3.0.1 (IEEE 1666-2023) with TLM 2.0 for configuration interfaces.

SystemC models serve as a fast simulation alternative to RTL simulation,
enabling:

- Early design exploration before RTL is finalized
- Software development with cycle-accurate timing feedback
- Verification reference for RTL implementation
- Hardware/software co-simulation

For the overall ADG design, see [spec-adg.md](./spec-adg.md).
For the builder API, see [spec-adg-api.md](./spec-adg-api.md).
For RTL generation, see [spec-adg-sv.md](./spec-adg-sv.md).

## SystemC Version Requirements

The generated code targets SystemC 3.0.1 (Accellera reference implementation):

- **Minimum version**: SystemC 3.0.1
- **C++ standard**: C++17 or later
- **TLM version**: TLM 2.0.6 (bundled with SystemC 3.0.x)

The reference installation path is `/path/to/tools/systemc/3.0.1`.

For preferred simulation tools and waveform formats, see
[spec-adg-tools.md](./spec-adg-tools.md).

## Simulation Abstraction Levels

The generated SystemC model supports two abstraction levels, selected at
compile time via preprocessor macros:

### Cycle-Accurate (CA) Mode

**Macro:** `FABRIC_SYSC_CYCLE_ACCURATE` (default)

- One-to-one correspondence with RTL behavior
- Clock-edge sensitive processes
- Exact handshake timing (valid/ready protocol)
- Suitable for verification against RTL

### Loosely-Timed (LT) Mode

**Macro:** `FABRIC_SYSC_LOOSELY_TIMED`

- Uses TLM temporal decoupling
- Quantum-based time advancement
- Faster simulation at the cost of cycle precision
- Suitable for software development

Select mode at compile time:

```bash
# Cycle-accurate (default)
g++ -DFABRIC_SYSC_CYCLE_ACCURATE ...

# Loosely-timed
g++ -DFABRIC_SYSC_LOOSELY_TIMED ...
```

## File Organization

### Loom Source (Implementation)

The export implementation and parameterized templates are part of the Loom
source tree:

```
include/loom/Hardware/SystemC/
  # Parameterized module templates (used by exporter, NOT referenced by output)

lib/loom/Hardware/SystemC/
  ADGExportSysC.cpp      # Export implementation
```

### Generated Output (Self-Contained)

Self-contained output is guaranteed by
[spec-adg.md](./spec-adg.md). This document defines the generated SystemC file
set and module structure.

Given `exportSysC(directory)` with module name `my_cgra`, the following files
are generated:

```
<directory>/
  my_cgra_top.h            # Top-level module header
  my_cgra_top.cpp          # Top-level module implementation
  my_cgra_config.h         # config_mem controller header
  my_cgra_config.cpp       # config_mem controller implementation
  my_cgra_testbench.h      # Example testbench header
  my_cgra_testbench.cpp    # Example testbench implementation
  my_cgra_main.cpp         # Example main() for standalone simulation
  my_cgra_addr.h           # C header with address definitions (shared with SV)
  CMakeLists.txt           # CMake build configuration
  lib/                     # Library modules (copied from Loom templates)
    fabric_pe.h            # Parameterized PE module
    fabric_pe_constant.h   # Parameterized constant PE module
    fabric_pe_load.h       # Parameterized load PE module
    fabric_pe_store.h      # Parameterized store PE module
    fabric_temporal_pe.h   # Parameterized temporal PE module
    fabric_switch.h        # Parameterized switch module
    fabric_temporal_sw.h   # Parameterized temporal switch module
    fabric_memory.h        # Parameterized memory module
    fabric_extmemory.h     # Parameterized external memory module
    fabric_add_tag.h       # Parameterized add_tag module
    fabric_map_tag.h       # Parameterized map_tag module
    fabric_del_tag.h       # Parameterized del_tag module
    fabric_stream.h        # Streaming interface definitions
    fabric_common.h        # Common definitions and utilities
```

## Module Hierarchy

### Top-Level Module

The top-level module (`my_cgra_top.h`) contains:

1. Module interface matching `fabric.module` ports
2. config_mem controller instantiation
3. All fabric operation instantiations
4. Internal signal wiring

**Header structure:**

```cpp
#ifndef MY_CGRA_TOP_H
#define MY_CGRA_TOP_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include "lib/fabric_common.h"
#include "lib/fabric_stream.h"

SC_MODULE(my_cgra_top) {
public:
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // TLM configuration interface (AXI-Lite equivalent)
    tlm_utils::simple_target_socket<my_cgra_top> cfg_socket;

    // Memref ports (TLM initiator sockets)
    // ... generated based on fabric.module interface

    // Native streaming ports
    fabric::stream_in<DATA_WIDTH>  native_in[NUM_NATIVE_INPUTS];
    fabric::stream_out<DATA_WIDTH> native_out[NUM_NATIVE_OUTPUTS];

    // Tagged streaming ports
    fabric::stream_in<DATA_WIDTH + TAG_WIDTH>  tagged_in[NUM_TAGGED_INPUTS];
    fabric::stream_out<DATA_WIDTH + TAG_WIDTH> tagged_out[NUM_TAGGED_OUTPUTS];

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    // Constructor
    SC_CTOR(my_cgra_top);

    // TLM transport method
    void b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay);

private:
    // config_mem array
    std::vector<uint32_t> config_mem;

    // Internal components
    // ... fabric module instances
};

#endif // MY_CGRA_TOP_H
```

### Streaming Interface

The streaming interface is defined in `lib/fabric_stream.h`:

```cpp
#ifndef FABRIC_STREAM_H
#define FABRIC_STREAM_H

#include <systemc>

namespace fabric {

// Streaming port bundle (valid/ready/data)
template<int WIDTH>
struct stream_signals {
    sc_core::sc_signal<bool>                  valid;
    sc_core::sc_signal<bool>                  ready;
    sc_core::sc_signal<sc_dt::sc_bv<WIDTH>>   data;
};

// Input port wrapper
template<int WIDTH>
struct stream_in {
    sc_core::sc_in<bool>                  valid;
    sc_core::sc_out<bool>                 ready;
    sc_core::sc_in<sc_dt::sc_bv<WIDTH>>   data;

    void bind(stream_signals<WIDTH>& sig) {
        valid.bind(sig.valid);
        ready.bind(sig.ready);
        data.bind(sig.data);
    }
};

// Output port wrapper
template<int WIDTH>
struct stream_out {
    sc_core::sc_out<bool>                 valid;
    sc_core::sc_in<bool>                  ready;
    sc_core::sc_out<sc_dt::sc_bv<WIDTH>>  data;

    void bind(stream_signals<WIDTH>& sig) {
        valid.bind(sig.valid);
        ready.bind(sig.ready);
        data.bind(sig.data);
    }
};

// Handshake helper: returns true when transfer occurs
inline bool handshake(bool valid, bool ready) {
    return valid && ready;
}

} // namespace fabric

#endif // FABRIC_STREAM_H
```

All streaming connections use the valid/ready handshake protocol defined in
[spec-adg.md](./spec-adg.md). See the "Streaming Handshake Protocol" section
in that document for the authoritative protocol rules.

For tagged interfaces, value/tag packing follows the authoritative convention
defined in [spec-dataflow.md](./spec-dataflow.md) (`!dataflow.tagged` type).

## Parameterized Fabric Modules

Each fabric operation type has a corresponding parameterized SystemC module.
Parameters correspond to hardware attributes from the Fabric MLIR spec.
`CONFIG_WIDTH` formulas remain authoritative in
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md); derived expressions in
the snippets below are implementation illustrations.

### fabric_pe.h

```cpp
template<
    int NUM_INPUTS = 2,
    int NUM_OUTPUTS = 1,
    std::array<int, 2> IN_DATA_WIDTH = {32, 32},   // per-input data width
    std::array<int, 1> OUT_DATA_WIDTH = {32},       // per-output data width
    int TAG_WIDTH = 0,      // 0 means native interface
    // Derived by exporter from PE-body analysis; not user-authored.
    bool HAS_DATAFLOW_STREAM = false,
    int LATENCY_MIN = 1,
    int LATENCY_TYP = 1,
    int LATENCY_MAX = 1,
    int INTERVAL_MIN = 1,
    int INTERVAL_TYP = 1,
    int INTERVAL_MAX = 1
>
SC_MODULE(fabric_pe) {
    // CONFIG_WIDTH: derived, not a template parameter
    //   Tagged non-constant non-load/store PE: NUM_OUTPUTS * TAG_WIDTH
    //   dataflow.stream PE:       +5 bits cont_cond_sel (one-hot)
    //   Other native compute PEs: 0
    static constexpr int STREAM_CONT_COND_WIDTH =
        HAS_DATAFLOW_STREAM ? 5 : 0;
    static constexpr int CONFIG_WIDTH =
        ((TAG_WIDTH > 0) ? NUM_OUTPUTS * TAG_WIDTH : 0) + STREAM_CONT_COND_WIDTH;

    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Input ports (per-port data width)
    // Each in_data[i] has width IN_DATA_WIDTH[i] + TAG_WIDTH.
    // The exporter generates per-port declarations for heterogeneous widths.
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];

    // Output ports (per-port data width)
    // Each out_data[o] has width OUT_DATA_WIDTH[o] + TAG_WIDTH.
    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];

    // Configuration (CONFIG_WIDTH bits; empty for native compute PEs)
    sc_core::sc_in<sc_dt::sc_bv<CONFIG_WIDTH>> cfg_data;

    // Compute function pointer (set during elaboration)
    // Port data types are generated per-port to match IN/OUT_DATA_WIDTH
    std::function<void()> compute;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_pe) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

### Constant PE Variant (fabric_pe_constant.h)

Constant PEs have exactly one output.

```cpp
template<
    int OUT_DATA_WIDTH = 32,
    int TAG_WIDTH = 0,
    int LATENCY_MIN = 0,
    int LATENCY_TYP = 0,
    int LATENCY_MAX = 0,
    int INTERVAL_MIN = 1,
    int INTERVAL_TYP = 1,
    int INTERVAL_MAX = 1
>
SC_MODULE(fabric_pe_constant) {
    // CONFIG_WIDTH: derived
    //   Native:  bitwidth(constant_value) = OUT_DATA_WIDTH
    //   Tagged:  bitwidth(constant_value) + TAG_WIDTH
    static constexpr int CONST_WIDTH = OUT_DATA_WIDTH;
    static constexpr int CONFIG_WIDTH =
        (TAG_WIDTH > 0) ? CONST_WIDTH + TAG_WIDTH : CONST_WIDTH;

    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    sc_core::sc_out<bool> out_valid;
    sc_core::sc_in<bool>  out_ready;
    sc_core::sc_out<sc_dt::sc_bv<OUT_DATA_WIDTH + TAG_WIDTH>> out_data;

    sc_core::sc_in<sc_dt::sc_bv<CONFIG_WIDTH>> cfg_data;

    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_pe_constant) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

No input ports: the constant value comes from `cfg_data`. See
[spec-fabric-pe.md](./spec-fabric-pe.md) for constant exclusivity rules.

### Load PE Variant (fabric_pe_load.h)

```cpp
template<
    int ADDR_WIDTH = 32,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 0,
    int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    int LQ_DEPTH = 0        // Required when HARDWARE_TYPE = 1
>
SC_MODULE(fabric_pe_load) {
    // CONFIG_WIDTH: derived
    //   TagOverwrite (tagged):  TAG_WIDTH (output_tag)
    //   TagOverwrite (native):  0
    //   TagTransparent:         0 (no output_tag)
    static constexpr int CONFIG_WIDTH =
        (HARDWARE_TYPE == 0 && TAG_WIDTH > 0) ? TAG_WIDTH : 0;

    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // From compute: address
    sc_core::sc_in<bool>                                   addr_valid;
    sc_core::sc_out<bool>                                  addr_ready;
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>>   addr_data;

    // From memory: returned data
    sc_core::sc_in<bool>                                   mem_data_valid;
    sc_core::sc_out<bool>                                  mem_data_ready;
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>>   mem_data;

    // Control token
    sc_core::sc_in<bool>  ctrl_valid;
    sc_core::sc_out<bool> ctrl_ready;

    // To memory: address
    sc_core::sc_out<bool>                                  mem_addr_valid;
    sc_core::sc_in<bool>                                   mem_addr_ready;
    sc_core::sc_out<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>>  mem_addr_data;

    // To compute: data
    sc_core::sc_out<bool>                                  data_valid;
    sc_core::sc_in<bool>                                   data_ready;
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>>  data_out;

    sc_core::sc_in<sc_dt::sc_bv<CONFIG_WIDTH>> cfg_data;

    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_pe_load) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
(TagOverwrite vs TagTransparent) and port role definitions.
Load/store PE latency and interval are fixed hardware behavior and are not
template parameters.

### Store PE Variant (fabric_pe_store.h)

```cpp
template<
    int ADDR_WIDTH = 32,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 0,
    int HARDWARE_TYPE = 0,  // 0 = TagOverwrite, 1 = TagTransparent
    int SQ_DEPTH = 0        // Required when HARDWARE_TYPE = 1
>
SC_MODULE(fabric_pe_store) {
    static constexpr int CONFIG_WIDTH =
        (HARDWARE_TYPE == 0 && TAG_WIDTH > 0) ? TAG_WIDTH : 0;

    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // From compute: address
    sc_core::sc_in<bool>                                   addr_valid;
    sc_core::sc_out<bool>                                  addr_ready;
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>>   addr_data;

    // From compute: data
    sc_core::sc_in<bool>                                   data_valid;
    sc_core::sc_out<bool>                                  data_ready;
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>>   data_in;

    // Control token
    sc_core::sc_in<bool>  ctrl_valid;
    sc_core::sc_out<bool> ctrl_ready;

    // To memory: address
    sc_core::sc_out<bool>                                  mem_addr_valid;
    sc_core::sc_in<bool>                                   mem_addr_ready;
    sc_core::sc_out<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>>  mem_addr_data;

    // To memory: data
    sc_core::sc_out<bool>                                  mem_data_valid;
    sc_core::sc_in<bool>                                   mem_data_ready;
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>>  mem_data_out;

    sc_core::sc_in<sc_dt::sc_bv<CONFIG_WIDTH>> cfg_data;

    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_pe_store) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

See [spec-fabric-pe.md](./spec-fabric-pe.md) for hardware type semantics
and port role definitions.
Load/store PE latency and interval are fixed hardware behavior and are not
template parameters.

### fabric_temporal_pe.h

```cpp
template<
    int NUM_INPUTS = 2,
    int NUM_OUTPUTS = 1,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4,
    int NUM_REGISTERS = 4,
    int NUM_INSTRUCTIONS = 16,
    int REG_FIFO_DEPTH = 2,
    int NUM_FU_TYPES = 2,
    // Placeholder default only. Exporter must emit the derived per-instance
    // width from spec-fabric-temporal_pe.md.
    int INSTRUCTION_WIDTH = 64,
    // Operand buffer mode parameters
    bool SHARED_OPERAND_BUFFER = false,  // false=per-instruction, true=shared
    int OPERAND_BUFFER_SIZE = 0          // shared mode only, range [1,8192]
>
SC_MODULE(fabric_temporal_pe) {
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration memory interface (instruction_mem only, no operand buffers)
    sc_core::sc_in<sc_dt::sc_bv<NUM_INSTRUCTIONS * INSTRUCTION_WIDTH>>
        cfg_instruction_mem;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_temporal_pe) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();

private:
    // Internal register file
    std::array<sc_dt::sc_bv<DATA_WIDTH>, NUM_REGISTERS> registers;

    // Operand buffer entry (runtime state, NOT configurable)
    struct operand_slot {
        bool valid;
        sc_dt::sc_bv<DATA_WIDTH> value;
    };

    // Per-instruction operand buffer
    // Conditional compilation based on SHARED_OPERAND_BUFFER
    std::array<std::array<operand_slot, NUM_INPUTS>, NUM_INSTRUCTIONS>
        per_inst_operand_buffer;

    // Shared operand buffer with per-tag FIFO semantics
    struct shared_buffer_entry {
        int position;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        std::array<operand_slot, NUM_INPUTS> operands;
        bool is_valid() const {
            for (int i = 0; i < NUM_INPUTS; i++)
                if (operands[i].valid) return true;
            return false;
        }
    };
    std::array<shared_buffer_entry, OPERAND_BUFFER_SIZE> shared_operand_buffers;

    // Instruction decode
    struct instruction {
        bool valid;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        int opcode;
        // Per-operand config
        struct operand_config {
            bool is_reg;
            int reg_idx;
        } operands[NUM_INPUTS];
        // Per-result config
        struct result_config {
            bool is_reg;
            int reg_idx;
            sc_dt::sc_bv<TAG_WIDTH> tag;
        } results[NUM_OUTPUTS];
    };
    std::array<instruction, NUM_INSTRUCTIONS> instruction_mem;

    void decode_instructions();
    int match_tag(const sc_dt::sc_bv<TAG_WIDTH>& tag);
};
```

Representation note: SystemC models `cfg_instruction_mem` as one flat packed
bitvector. The SystemVerilog template uses a 2D packed array with equivalent
bit content. Both follow the same packing and bit-order rules from
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md).

`INSTRUCTION_WIDTH = 64` is only a placeholder default in the template
signature.

Recommended defensive check (compile-time/elaboration-time):

```cpp
static constexpr int log2_ceil_constexpr(int v) {
    return (v <= 1) ? 0 : 1 + log2_ceil_constexpr((v + 1) >> 1);
}

static constexpr int OPERAND_CONFIG_WIDTH =
    (NUM_REGISTERS > 0) ? (1 + log2_ceil_constexpr(NUM_REGISTERS)) : 0;
static constexpr int RESULT_WIDTH = OPERAND_CONFIG_WIDTH + TAG_WIDTH;
static constexpr int DERIVED_INSTRUCTION_WIDTH =
    1 + TAG_WIDTH
    + ((NUM_FU_TYPES > 1) ? log2_ceil_constexpr(NUM_FU_TYPES) : 0)
    + NUM_INPUTS * OPERAND_CONFIG_WIDTH
    + NUM_OUTPUTS * RESULT_WIDTH;

static_assert(INSTRUCTION_WIDTH == DERIVED_INSTRUCTION_WIDTH,
              "INSTRUCTION_WIDTH must match derived temporal_pe formula");
```

### fabric_switch.h

```cpp
template<
    int NUM_INPUTS = 4,
    int NUM_OUTPUTS = 4,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 0,
    int NUM_CONNECTED = 16
>
SC_MODULE(fabric_switch) {
    static constexpr int CONNECTIVITY_BITS = NUM_OUTPUTS * NUM_INPUTS;
    sc_dt::sc_bv<CONNECTIVITY_BITS> connectivity;
    static int popcount_bv(const sc_dt::sc_bv<CONNECTIVITY_BITS>& bits) {
        int count = 0;
        for (int i = 0; i < CONNECTIVITY_BITS; ++i)
            if (bits[i] == sc_dt::SC_LOGIC_1) ++count;
        return count;
    }

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration: one bit per connected position
    sc_core::sc_in<sc_dt::sc_bv<NUM_CONNECTED>> cfg_route_table;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_HAS_PROCESS(fabric_switch);
    explicit fabric_switch(
        sc_core::sc_module_name name,
        const sc_dt::sc_bv<CONNECTIVITY_BITS>& connectivity_mask =
            sc_dt::sc_bv<CONNECTIVITY_BITS>(-1))
        : sc_core::sc_module(name), connectivity(connectivity_mask) {
        if (NUM_CONNECTED != popcount_bv(connectivity)) {
            SC_REPORT_ERROR("fabric_switch",
                            "NUM_CONNECTED must equal popcount(connectivity)");
        }
        SC_METHOD(route_method);
        sensitive << cfg_route_table;
        for (int i = 0; i < NUM_INPUTS; ++i) {
            sensitive << in_valid[i] << in_data[i];
        }
        for (int o = 0; o < NUM_OUTPUTS; ++o) {
            sensitive << out_ready[o];
        }
    }

    void route_method();

private:
    // Decode connectivity mask to input-output mapping
    void decode_routes();
};
```

`fabric_switch` is combinational (no `clk`/`rst_n` ports). In C++17,
`sc_dt::sc_bv` cannot be used as a non-type template parameter, so
`connectivity` is provided as a constructor argument (or equivalent constant
object bound at instantiation). The exporter must emit `connectivity` and
`NUM_CONNECTED` consistently; the constructor check is a defensive guard.

### fabric_temporal_sw.h

```cpp
template<
    int NUM_INPUTS = 4,
    int NUM_OUTPUTS = 4,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4,
    int NUM_ROUTE_TABLE = 8,
    int NUM_CONNECTED = 16
>
SC_MODULE(fabric_temporal_sw) {
    static constexpr int CONNECTIVITY_BITS = NUM_OUTPUTS * NUM_INPUTS;
    static constexpr int SLOT_WIDTH = 1 + TAG_WIDTH + NUM_CONNECTED;
    sc_dt::sc_bv<CONNECTIVITY_BITS> connectivity;
    static int popcount_bv(const sc_dt::sc_bv<CONNECTIVITY_BITS>& bits) {
        int count = 0;
        for (int i = 0; i < CONNECTIVITY_BITS; ++i)
            if (bits[i] == sc_dt::SC_LOGIC_1) ++count;
        return count;
    }

    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration memory
    sc_core::sc_in<sc_dt::sc_bv<NUM_ROUTE_TABLE * SLOT_WIDTH>> cfg_route_table;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_HAS_PROCESS(fabric_temporal_sw);
    explicit fabric_temporal_sw(
        sc_core::sc_module_name name,
        const sc_dt::sc_bv<CONNECTIVITY_BITS>& connectivity_mask =
            sc_dt::sc_bv<CONNECTIVITY_BITS>(-1))
        : sc_core::sc_module(name), connectivity(connectivity_mask) {
        if (NUM_CONNECTED != popcount_bv(connectivity)) {
            SC_REPORT_ERROR("fabric_temporal_sw",
                            "NUM_CONNECTED must equal popcount(connectivity)");
        }
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();

private:
    struct route_slot {
        bool valid;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        uint32_t route_mask;  // K bits for connected positions
    };
    std::array<route_slot, NUM_ROUTE_TABLE> route_table;

    void decode_route_table();
    int match_tag(const sc_dt::sc_bv<TAG_WIDTH>& tag);
};
```

`SLOT_WIDTH` is derived and must not be set independently. The exporter must
emit `connectivity` and `NUM_CONNECTED` consistently; constructor checks provide
defensive guards.

### fabric_memory.h

```cpp
template<
    int LD_COUNT = 1,
    int ST_COUNT = 1,
    int DATA_WIDTH = 32,
    int ADDR_WIDTH = 32,
    int TAG_WIDTH = 0,       // 0 for single-port (native)
    int LSQ_DEPTH = 4,
    bool PRIVATE = true,
    int MEM_DEPTH = 256
>
SC_MODULE(fabric_memory) {
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Load ports
    sc_core::sc_in<bool>  ld_addr_valid[LD_COUNT];
    sc_core::sc_out<bool> ld_addr_ready[LD_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>> ld_addr_data[LD_COUNT];

    sc_core::sc_out<bool> ld_data_valid[LD_COUNT];
    sc_core::sc_in<bool>  ld_data_ready[LD_COUNT];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> ld_data_data[LD_COUNT];

    sc_core::sc_out<bool> ld_done_valid[LD_COUNT];
    sc_core::sc_in<bool>  ld_done_ready[LD_COUNT];

    // Store ports
    sc_core::sc_in<bool>  st_addr_valid[ST_COUNT];
    sc_core::sc_out<bool> st_addr_ready[ST_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>> st_addr_data[ST_COUNT];

    sc_core::sc_in<bool>  st_data_valid[ST_COUNT];
    sc_core::sc_out<bool> st_data_ready[ST_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> st_data_data[ST_COUNT];

    sc_core::sc_out<bool> st_done_valid[ST_COUNT];
    sc_core::sc_in<bool>  st_done_ready[ST_COUNT];

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_memory) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();

private:
    std::vector<sc_dt::sc_bv<DATA_WIDTH>> mem_array;
};
```

### fabric_extmemory.h

```cpp
template<
    int LD_COUNT = 1,
    int ST_COUNT = 1,
    int DATA_WIDTH = 32,
    int ADDR_WIDTH = 32,
    int TAG_WIDTH = 0,
    int LSQ_DEPTH = 4
>
SC_MODULE(fabric_extmemory) {
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Load ports (same as fabric_memory)
    sc_core::sc_in<bool>  ld_addr_valid[LD_COUNT];
    sc_core::sc_out<bool> ld_addr_ready[LD_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>> ld_addr_data[LD_COUNT];

    sc_core::sc_out<bool> ld_data_valid[LD_COUNT];
    sc_core::sc_in<bool>  ld_data_ready[LD_COUNT];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> ld_data_data[LD_COUNT];

    sc_core::sc_out<bool> ld_done_valid[LD_COUNT];
    sc_core::sc_in<bool>  ld_done_ready[LD_COUNT];

    // Store ports (same as fabric_memory)
    sc_core::sc_in<bool>  st_addr_valid[ST_COUNT];
    sc_core::sc_out<bool> st_addr_ready[ST_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<ADDR_WIDTH + TAG_WIDTH>> st_addr_data[ST_COUNT];

    sc_core::sc_in<bool>  st_data_valid[ST_COUNT];
    sc_core::sc_out<bool> st_data_ready[ST_COUNT];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> st_data_data[ST_COUNT];

    sc_core::sc_out<bool> st_done_valid[ST_COUNT];
    sc_core::sc_in<bool>  st_done_ready[ST_COUNT];

    // External memory TLM initiator socket
    tlm_utils::simple_initiator_socket<fabric_extmemory> mem_socket;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_extmemory) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

### fabric_add_tag.h

```cpp
template<
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4
    // CONFIG_WIDTH = TAG_WIDTH
>
SC_MODULE(fabric_add_tag) {
    // Input: native value
    sc_core::sc_in<bool>                          in_valid;
    sc_core::sc_out<bool>                         in_ready;
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH>>      in_data;

    // Output: tagged value
    sc_core::sc_out<bool>                         out_valid;
    sc_core::sc_in<bool>                          out_ready;
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data;

    // Configuration: tag value
    sc_core::sc_in<sc_dt::sc_bv<TAG_WIDTH>>       cfg_tag;

    SC_CTOR(fabric_add_tag) {
        SC_METHOD(tag_method);
        sensitive << in_valid << out_ready << in_data << cfg_tag;
    }

    void tag_method();
};
```

### fabric_map_tag.h

```cpp
template<
    int DATA_WIDTH = 32,
    int IN_TAG_WIDTH = 4,
    int OUT_TAG_WIDTH = 4,
    int TABLE_SIZE = 16
    // CONFIG_WIDTH = TABLE_SIZE * (1 + IN_TAG_WIDTH + OUT_TAG_WIDTH)
>
SC_MODULE(fabric_map_tag) {
    // Input: tagged value with input tag type
    sc_core::sc_in<bool>                              in_valid;
    sc_core::sc_out<bool>                             in_ready;
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + IN_TAG_WIDTH>> in_data;

    // Output: tagged value with output tag type
    sc_core::sc_out<bool>                             out_valid;
    sc_core::sc_in<bool>                              out_ready;
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + OUT_TAG_WIDTH>> out_data;

    // Configuration: mapping table
    sc_core::sc_in<sc_dt::sc_bv<TABLE_SIZE * (1 + IN_TAG_WIDTH + OUT_TAG_WIDTH)>> cfg_table;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_map_tag) {
        SC_METHOD(map_method);
        sensitive << in_valid << out_ready << in_data << cfg_table;
    }

    void map_method();
};
```

### fabric_del_tag.h

```cpp
template<
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4
>
SC_MODULE(fabric_del_tag) {
    // Input: tagged value
    sc_core::sc_in<bool>                              in_valid;
    sc_core::sc_out<bool>                             in_ready;
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data;

    // Output: native value (tag stripped)
    sc_core::sc_out<bool>                             out_valid;
    sc_core::sc_in<bool>                              out_ready;
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH>>         out_data;

    SC_CTOR(fabric_del_tag) {
        SC_METHOD(del_method);
        sensitive << in_valid << out_ready << in_data;
    }

    void del_method();
};
```

`fabric_add_tag` and `fabric_del_tag` intentionally do not expose
`error_valid/error_code` ports. They are unconditional combinational data
transformations with no runtime failure mode. `fabric_map_tag` keeps error
ports because table matching can fail at runtime/configuration time.

## config_mem Design

Shared config_mem semantics (address allocation, `CONFIG_WIDTH` derivation,
bit packing, and alignment) are defined authoritatively in
[spec-fabric-config_mem.md](./spec-fabric-config_mem.md).

This document only specifies the SystemC backend surface:

- Transport: TLM 2.0 `simple_target_socket` (`b_transport`)
- Storage: host-visible `std::vector<uint32_t> config_mem`
- Propagation: backend-specific `propagate_config()` fanout
- Software-visible constants: shared `<module>_addr.h` header

### TLM Interface

The config_mem uses `tlm_utils::simple_target_socket` for blocking transport:

```cpp
void my_cgra_top::b_transport(
    tlm::tlm_generic_payload& trans,
    sc_core::sc_time& delay
) {
    tlm::tlm_command cmd = trans.get_command();
    uint64_t addr = trans.get_address();
    uint8_t* data = trans.get_data_ptr();
    uint32_t len = trans.get_data_length();

    uint32_t word_idx = addr / 4;

    if (word_idx >= config_mem.size()) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        return;
    }

    if (cmd == tlm::TLM_READ_COMMAND) {
        // Host read
        uint32_t value = config_mem[word_idx];
        memcpy(data, &value, std::min(len, 4u));
    } else if (cmd == tlm::TLM_WRITE_COMMAND) {
        // Host write
        uint32_t value = 0;
        memcpy(&value, data, std::min(len, 4u));
        config_mem[word_idx] = value;
        propagate_config();  // Update module configurations
    }

    trans.set_response_status(tlm::TLM_OK_RESPONSE);
}
```

## Error Reporting

Modules with runtime/configuration failure modes report errors through error
signals:

```cpp
sc_core::sc_out<bool>     error_valid;
sc_core::sc_out<uint16_t> error_code;
```

Error codes match the values defined in
[spec-fabric-error.md](./spec-fabric-error.md):

`fabric_add_tag` and `fabric_del_tag` are exception paths: they do not expose
error ports because they have no runtime failure mode.

The top-level module aggregates errors using priority encoding (lower code =
higher priority). The first error is latched until reset.

**Error reporting example:**

```cpp
void fabric_temporal_pe::report_error(uint16_t code) {
    if (!error_valid.read()) {  // Only latch first error
        error_valid.write(true);
        error_code.write(code);
        SC_REPORT_ERROR("fabric_temporal_pe",
            ("Runtime error: code " + std::to_string(code)).c_str());
    }
}
```

## Testbench Generation

The generated testbench (`my_cgra_testbench.h/cpp`) provides:

1. Clock generation
2. Reset sequence
3. Configuration loading from binary file
4. Stimulus injection helpers
5. Output verification helpers
6. VCD trace generation

**Testbench structure:**

```cpp
SC_MODULE(my_cgra_testbench) {
    // Clock and reset
    sc_core::sc_clock clk;
    sc_core::sc_signal<bool> rst_n;

    // DUT instance
    my_cgra_top dut;

    // TLM initiator for configuration
    tlm_utils::simple_initiator_socket<my_cgra_testbench> cfg_init;

    // Streaming connections
    fabric::stream_signals<DATA_WIDTH> native_in_sig[NUM_NATIVE_INPUTS];
    fabric::stream_signals<DATA_WIDTH> native_out_sig[NUM_NATIVE_OUTPUTS];
    // ...

    SC_CTOR(my_cgra_testbench)
        : clk("clk", 10, sc_core::SC_NS)  // 100 MHz
        , dut("dut")
    {
        // Bind ports
        dut.clk(clk);
        dut.rst_n(rst_n);
        cfg_init.bind(dut.cfg_socket);
        // ...

        SC_THREAD(main_thread);
    }

    void main_thread();

    // Helper methods
    void reset();
    void configure(const std::string& config_file);
    void send_token(int port, uint64_t data);
    uint64_t receive_token(int port);
    void wait_cycles(int n);
};
```

**Example main.cpp:**

```cpp
#include "my_cgra_testbench.h"

int sc_main(int argc, char* argv[]) {
    // Parse arguments
    std::string config_file = "config.bin";
    if (argc > 1) config_file = argv[1];

    // Create testbench
    my_cgra_testbench tb("tb");

    // Enable VCD tracing
    sc_core::sc_trace_file* tf = sc_core::sc_create_vcd_trace_file("waves");
    sc_core::sc_trace(tf, tb.clk, "clk");
    sc_core::sc_trace(tf, tb.rst_n, "rst_n");
    // ... trace other signals

    // Run simulation
    sc_core::sc_start();

    // Cleanup
    sc_core::sc_close_vcd_trace_file(tf);

    return 0;
}
```

## Build System

### CMake Configuration

The generated `CMakeLists.txt` provides a complete build configuration:

```cmake
cmake_minimum_required(VERSION 3.16)
project(my_cgra_sysc CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find SystemC (prefer 3.0.1)
set(SYSTEMC_HOME "/path/to/tools/systemc/3.0.1" CACHE PATH "SystemC installation")
find_library(SYSTEMC_LIBRARY
    NAMES systemc
    PATHS ${SYSTEMC_HOME}/lib64 ${SYSTEMC_HOME}/lib
    NO_DEFAULT_PATH
)
find_path(SYSTEMC_INCLUDE_DIR
    NAMES systemc.h
    PATHS ${SYSTEMC_HOME}/include
    NO_DEFAULT_PATH
)

if(NOT SYSTEMC_LIBRARY OR NOT SYSTEMC_INCLUDE_DIR)
    message(FATAL_ERROR "SystemC not found. Set SYSTEMC_HOME.")
endif()

# Abstraction level selection
option(FABRIC_CYCLE_ACCURATE "Enable cycle-accurate simulation" ON)
if(FABRIC_CYCLE_ACCURATE)
    add_compile_definitions(FABRIC_SYSC_CYCLE_ACCURATE)
else()
    add_compile_definitions(FABRIC_SYSC_LOOSELY_TIMED)
endif()

# Library target (header-only)
add_library(fabric_lib INTERFACE)
target_include_directories(fabric_lib INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib
    ${SYSTEMC_INCLUDE_DIR}
)

# Main simulation executable
add_executable(my_cgra_sim
    my_cgra_top.cpp
    my_cgra_config.cpp
    my_cgra_testbench.cpp
    my_cgra_main.cpp
)
target_link_libraries(my_cgra_sim PRIVATE
    fabric_lib
    ${SYSTEMC_LIBRARY}
    pthread
)
target_include_directories(my_cgra_sim PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${SYSTEMC_INCLUDE_DIR}
)

# Installation
install(TARGETS my_cgra_sim DESTINATION bin)
install(FILES my_cgra_addr.h DESTINATION include)
```

### Build Commands

```bash
# Configure
cmake -B build -DSYSTEMC_HOME=/path/to/tools/systemc/3.0.1

# Build (cycle-accurate, default)
cmake --build build

# Build (loosely-timed)
cmake -B build -DFABRIC_CYCLE_ACCURATE=OFF
cmake --build build

# Run simulation
./build/my_cgra_sim config.bin
```

## Simulation Performance

### Cycle-Accurate Mode

- Timing: Exact cycle count matches RTL
- Speed: ~10-100x faster than RTL simulation (Verilator/VCS)
- Use case: Verification, debugging, small test cases

### Loosely-Timed Mode

- Timing: Approximate (quantum-based)
- Speed: ~100-1000x faster than cycle-accurate
- Use case: Software development, large workloads

**Quantum configuration:**

```cpp
// In testbench or main
sc_core::sc_set_time_resolution(1, sc_core::SC_PS);
tlm::tlm_global_quantum::instance().set(sc_core::sc_time(100, sc_core::SC_NS));
```

## Co-Simulation Support

The SystemC model supports co-simulation with RTL for verification. See
[spec-adg-tools.md](./spec-adg-tools.md) for detailed simulation workflows.

### Mixed SystemC/RTL Wrapper

```cpp
// Co-simulation wrapper comparing SystemC model with RTL
#include "Vmy_cgra_rtl.h"  // Verilated or VCS-compiled RTL
#include "my_cgra_top.h"   // SystemC model

SC_MODULE(cosim_wrapper) {
    Vmy_cgra_rtl rtl_dut;
    my_cgra_top  sysc_dut;

    // Compare outputs cycle-by-cycle
    SC_THREAD(compare_thread);
};
```

## Debugging Features

### Waveform Trace Generation

For waveform format priorities (FSDB > FST > VCD) and detailed simulation
workflows, see [spec-adg-tools.md](./spec-adg-tools.md).

**SystemC trace setup examples:**

```cpp
// FSDB tracing (VCS/Verdi)
#ifdef FABRIC_USE_FSDB
#include "fsdb_trace.h"
void testbench::setup_trace() {
    fsdbDumpfile("waves.fsdb");
    fsdbDumpvars(0, this);
}
#endif

// FST tracing (Verilator)
#ifdef FABRIC_USE_FST
#include "verilated_fst_sc.h"
void testbench::setup_trace() {
    Verilated::traceEverOn(true);
    VerilatedFstSc* tfp = new VerilatedFstSc;
    dut.trace(tfp, 99);
    tfp->open("waves.fst");
}
#endif

// VCD tracing (standard SystemC fallback)
#ifdef FABRIC_USE_VCD
sc_trace_file* tf = sc_create_vcd_trace_file("waves");
tf->set_time_unit(1, SC_NS);
sc_trace(tf, dut.clk, "top.clk");
sc_trace(tf, dut.rst_n, "top.rst_n");
#endif
```

### SC_REPORT Messages

The generated modules use `SC_REPORT_*` macros for diagnostic messages:

```cpp
SC_REPORT_INFO("fabric_pe", "Processing input token");
SC_REPORT_WARNING("fabric_switch", "Input has no enabled route");
SC_REPORT_ERROR("fabric_temporal_pe", "Tag mismatch: no instruction found");
```

Control verbosity at runtime:

```cpp
sc_core::sc_report_handler::set_verbosity_level(sc_core::SC_DEBUG);
```

### Assertions

The generated code includes assertions gated by `FABRIC_SYSC_ASSERTIONS`:

```cpp
#ifdef FABRIC_SYSC_ASSERTIONS
    sc_assert(in_valid[i].read() || !pending_output);
#endif
```

Enable assertions:

```bash
cmake -DFABRIC_SYSC_ASSERTIONS=ON ...
```

## Related Documents

- [spec-adg.md](./spec-adg.md): ADG overall design
- [spec-adg-api.md](./spec-adg-api.md): ADGBuilder API reference
- [spec-adg-tools.md](./spec-adg-tools.md): Simulation tools and waveform formats
- [spec-adg-sv.md](./spec-adg-sv.md): SystemVerilog generation specification
- [spec-fabric.md](./spec-fabric.md): Fabric MLIR dialect specification
- [spec-fabric-error.md](./spec-fabric-error.md): Error code definitions
