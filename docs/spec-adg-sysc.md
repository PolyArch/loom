# ADG SystemC Generation Specification

## Overview

This document specifies the SystemC output format generated by
`ADGBuilder::exportSysC()`. The output is a cycle-accurate simulation model
using SystemC 3.0.2 (IEEE 1666-2023) with TLM 2.0 for configuration interfaces.

SystemC models serve as a fast simulation alternative to RTL simulation,
enabling:

- Early design exploration before RTL is finalized
- Software development with cycle-accurate timing feedback
- Verification reference for RTL implementation
- Hardware/software co-simulation

For the overall ADG design, see [spec-adg.md](./spec-adg.md).
For the builder API, see [spec-adg-api.md](./spec-adg-api.md).
For RTL generation, see [spec-adg-sv.md](./spec-adg-sv.md).

## SystemC Version Requirements

The generated code targets SystemC 3.0.2 (Accellera reference implementation):

- **Minimum version**: SystemC 3.0.1
- **Recommended version**: SystemC 3.0.2
- **C++ standard**: C++17 or later
- **TLM version**: TLM 2.0.6 (bundled with SystemC 3.0.x)

The reference installation path is `/path/to/tools/systemc/3.0.2`.

For preferred simulation tools and waveform formats, see
[spec-adg-tools.md](./spec-adg-tools.md).

## Simulation Abstraction Levels

The generated SystemC model supports two abstraction levels, selected at
compile time via preprocessor macros:

### Cycle-Accurate (CA) Mode

**Macro:** `FABRIC_SYSC_CYCLE_ACCURATE` (default)

- One-to-one correspondence with RTL behavior
- Clock-edge sensitive processes
- Exact handshake timing (valid/ready protocol)
- Suitable for verification against RTL

### Loosely-Timed (LT) Mode

**Macro:** `FABRIC_SYSC_LOOSELY_TIMED`

- Uses TLM temporal decoupling
- Quantum-based time advancement
- Faster simulation at the cost of cycle precision
- Suitable for software development

Select mode at compile time:

```bash
# Cycle-accurate (default)
g++ -DFABRIC_SYSC_CYCLE_ACCURATE ...

# Loosely-timed
g++ -DFABRIC_SYSC_LOOSELY_TIMED ...
```

## File Organization

### Loom Source (Implementation)

The export implementation and parameterized templates are part of the Loom
source tree:

```
include/loom/Hardware/SystemC/
  # Parameterized module templates (used by exporter, NOT referenced by output)

lib/loom/Hardware/SystemC/
  ADGExportSysC.cpp      # Export implementation
```

### Generated Output (Self-Contained)

**IMPORTANT:** The exported output is completely self-contained. It does not
reference or depend on any files in the Loom installation. All required files
are either generated or copied into the output directory.

Given `exportSysC(directory)` with module name `my_cgra`, the following files
are generated:

```
<directory>/
  my_cgra_top.h            # Top-level module header
  my_cgra_top.cpp          # Top-level module implementation
  my_cgra_config.h         # config_mem controller header
  my_cgra_config.cpp       # config_mem controller implementation
  my_cgra_testbench.h      # Example testbench header
  my_cgra_testbench.cpp    # Example testbench implementation
  my_cgra_main.cpp         # Example main() for standalone simulation
  my_cgra_addr.h           # C header with address definitions (shared with SV)
  CMakeLists.txt           # CMake build configuration
  lib/                     # Library modules (copied from Loom templates)
    fabric_pe.h            # Parameterized PE module
    fabric_temporal_pe.h   # Parameterized temporal PE module
    fabric_switch.h        # Parameterized switch module
    fabric_temporal_sw.h   # Parameterized temporal switch module
    fabric_memory.h        # Parameterized memory module
    fabric_extmemory.h     # Parameterized external memory module
    fabric_add_tag.h       # Parameterized add_tag module
    fabric_map_tag.h       # Parameterized map_tag module
    fabric_del_tag.h       # Parameterized del_tag module
    fabric_stream.h        # Streaming interface definitions
    fabric_common.h        # Common definitions and utilities
```

The entire `<directory>/` can be moved, archived, or shared without requiring
access to the Loom installation.

## Module Hierarchy

### Top-Level Module

The top-level module (`my_cgra_top.h`) contains:

1. Module interface matching `fabric.module` ports
2. config_mem controller instantiation
3. All fabric operation instantiations
4. Internal signal wiring

**Header structure:**

```cpp
#ifndef MY_CGRA_TOP_H
#define MY_CGRA_TOP_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include "lib/fabric_common.h"
#include "lib/fabric_stream.h"

SC_MODULE(my_cgra_top) {
public:
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // TLM configuration interface (AXI-Lite equivalent)
    tlm_utils::simple_target_socket<my_cgra_top> cfg_socket;

    // Memref ports (TLM initiator sockets)
    // ... generated based on fabric.module interface

    // Native streaming ports
    fabric::stream_in<DATA_WIDTH>  native_in[NUM_NATIVE_INPUTS];
    fabric::stream_out<DATA_WIDTH> native_out[NUM_NATIVE_OUTPUTS];

    // Tagged streaming ports
    fabric::stream_in<DATA_WIDTH + TAG_WIDTH>  tagged_in[NUM_TAGGED_INPUTS];
    fabric::stream_out<DATA_WIDTH + TAG_WIDTH> tagged_out[NUM_TAGGED_OUTPUTS];

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    // Constructor
    SC_CTOR(my_cgra_top);

    // TLM transport method
    void b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay);

private:
    // config_mem array
    std::vector<uint32_t> config_mem;

    // Internal components
    // ... fabric module instances
};

#endif // MY_CGRA_TOP_H
```

### Streaming Interface

The streaming interface is defined in `lib/fabric_stream.h`:

```cpp
#ifndef FABRIC_STREAM_H
#define FABRIC_STREAM_H

#include <systemc>

namespace fabric {

// Streaming port bundle (valid/ready/data)
template<int WIDTH>
struct stream_signals {
    sc_core::sc_signal<bool>                  valid;
    sc_core::sc_signal<bool>                  ready;
    sc_core::sc_signal<sc_dt::sc_bv<WIDTH>>   data;
};

// Input port wrapper
template<int WIDTH>
struct stream_in {
    sc_core::sc_in<bool>                  valid;
    sc_core::sc_out<bool>                 ready;
    sc_core::sc_in<sc_dt::sc_bv<WIDTH>>   data;

    void bind(stream_signals<WIDTH>& sig) {
        valid.bind(sig.valid);
        ready.bind(sig.ready);
        data.bind(sig.data);
    }
};

// Output port wrapper
template<int WIDTH>
struct stream_out {
    sc_core::sc_out<bool>                 valid;
    sc_core::sc_in<bool>                  ready;
    sc_core::sc_out<sc_dt::sc_bv<WIDTH>>  data;

    void bind(stream_signals<WIDTH>& sig) {
        valid.bind(sig.valid);
        ready.bind(sig.ready);
        data.bind(sig.data);
    }
};

// Handshake helper: returns true when transfer occurs
inline bool handshake(bool valid, bool ready) {
    return valid && ready;
}

} // namespace fabric

#endif // FABRIC_STREAM_H
```

**Handshake protocol:**

- Transfer occurs when `valid && ready` on rising clock edge
- `valid` must not depend combinationally on `ready`
- `ready` may depend combinationally on `valid`
- Once asserted, `valid` must remain high until transfer completes

For tagged interfaces, the data signal contains both value and tag:

```
data[TAG_WIDTH+DATA_WIDTH-1:DATA_WIDTH] = tag
data[DATA_WIDTH-1:0] = value
```

## Parameterized Fabric Modules

Each fabric operation type has a corresponding parameterized SystemC module.
Parameters correspond to hardware attributes from the Fabric MLIR spec.

### fabric_pe.h

```cpp
template<
    int NUM_INPUTS = 2,
    int NUM_OUTPUTS = 1,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 0,      // 0 means native interface
    int LATENCY_MIN = 1,
    int LATENCY_TYP = 1,
    int LATENCY_MAX = 1,
    int INTERVAL_MIN = 1,
    int INTERVAL_TYP = 1,
    int INTERVAL_MAX = 1
>
SC_MODULE(fabric_pe) {
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Input ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    // Output ports
    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration (for output_tag when tagged, or constant value)
    sc_core::sc_in<sc_dt::sc_bv<CONFIG_WIDTH>> cfg_data;

    // Compute function pointer (set during elaboration)
    std::function<void(
        const std::array<sc_dt::sc_bv<DATA_WIDTH>, NUM_INPUTS>&,
        std::array<sc_dt::sc_bv<DATA_WIDTH>, NUM_OUTPUTS>&
    )> compute;

    SC_CTOR(fabric_pe) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();
};
```

### fabric_temporal_pe.h

```cpp
template<
    int NUM_INPUTS = 2,
    int NUM_OUTPUTS = 1,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4,
    int NUM_REGISTER = 4,
    int NUM_INSTRUCTION = 16,
    int NUM_INSTANCE = 2,
    int NUM_FU_TYPES = 2,
    int INSTRUCTION_CONFIG_WIDTH = 64,
    // Operand buffer mode parameters
    bool ENABLE_SHARED_OPERAND_BUFFER = false,  // false=Mode A, true=Mode B
    int OPERAND_BUFFER_SIZE = 0                  // Mode B only, range [1,8192]
>
SC_MODULE(fabric_temporal_pe) {
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration memory interface (instruction_mem only, no operand buffers)
    sc_core::sc_in<sc_dt::sc_bv<NUM_INSTRUCTION * INSTRUCTION_CONFIG_WIDTH>>
        cfg_instruction_mem;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_temporal_pe) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();

private:
    // Internal register file
    std::array<sc_dt::sc_bv<DATA_WIDTH>, NUM_REGISTER> registers;

    // Operand buffer entry (runtime state, NOT configurable)
    struct operand_slot {
        bool valid;
        sc_dt::sc_bv<DATA_WIDTH> value;
    };

    // Mode A: per-instruction operand buffer
    // Conditional compilation based on ENABLE_SHARED_OPERAND_BUFFER
    std::array<std::array<operand_slot, NUM_INPUTS>, NUM_INSTRUCTION>
        operand_buffers_mode_a;

    // Mode B: shared operand buffer with per-tag FIFO semantics
    struct shared_buffer_entry {
        int position;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        std::array<operand_slot, NUM_INPUTS> operands;
        bool is_valid() const {
            for (int i = 0; i < NUM_INPUTS; i++)
                if (operands[i].valid) return true;
            return false;
        }
    };
    std::array<shared_buffer_entry, OPERAND_BUFFER_SIZE> operand_buffers_mode_b;

    // Instruction decode
    struct instruction {
        bool valid;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        int opcode;
        // Per-operand config
        struct operand_config {
            bool is_reg;
            int reg_idx;
        } operands[NUM_INPUTS];
        // Per-result config
        struct result_config {
            bool is_reg;
            int reg_idx;
            sc_dt::sc_bv<TAG_WIDTH> tag;
        } results[NUM_OUTPUTS];
    };
    std::array<instruction, NUM_INSTRUCTION> instruction_mem;

    void decode_instructions();
    int match_tag(const sc_dt::sc_bv<TAG_WIDTH>& tag);
};
```

### fabric_switch.h

```cpp
template<
    int NUM_INPUTS = 4,
    int NUM_OUTPUTS = 4,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 0,
    uint64_t CONNECTIVITY = 0xFFFFFFFFFFFFFFFFULL,  // bit mask
    int NUM_CONNECTED = 16  // popcount(CONNECTIVITY)
>
SC_MODULE(fabric_switch) {
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration: one bit per connected position
    sc_core::sc_in<sc_dt::sc_bv<NUM_CONNECTED>> cfg_route_table;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_switch) {
        SC_METHOD(route_method);
        sensitive << clk.pos();
    }

    void route_method();

private:
    // Decode connectivity mask to input-output mapping
    void decode_routes();
};
```

### fabric_temporal_sw.h

```cpp
template<
    int NUM_INPUTS = 4,
    int NUM_OUTPUTS = 4,
    int DATA_WIDTH = 32,
    int TAG_WIDTH = 4,
    int NUM_ROUTE_TABLE = 8,
    uint64_t CONNECTIVITY = 0xFFFFFFFFFFFFFFFFULL,
    int SLOT_WIDTH = 16
>
SC_MODULE(fabric_temporal_sw) {
    // Clock and reset
    sc_core::sc_in<bool> clk;
    sc_core::sc_in<bool> rst_n;

    // Streaming ports
    sc_core::sc_in<bool>  in_valid[NUM_INPUTS];
    sc_core::sc_out<bool> in_ready[NUM_INPUTS];
    sc_core::sc_in<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> in_data[NUM_INPUTS];

    sc_core::sc_out<bool> out_valid[NUM_OUTPUTS];
    sc_core::sc_in<bool>  out_ready[NUM_OUTPUTS];
    sc_core::sc_out<sc_dt::sc_bv<DATA_WIDTH + TAG_WIDTH>> out_data[NUM_OUTPUTS];

    // Configuration memory
    sc_core::sc_in<sc_dt::sc_bv<NUM_ROUTE_TABLE * SLOT_WIDTH>> cfg_route_table;

    // Error reporting
    sc_core::sc_out<bool>     error_valid;
    sc_core::sc_out<uint16_t> error_code;

    SC_CTOR(fabric_temporal_sw) {
        SC_THREAD(main_thread);
        sensitive << clk.pos();
    }

    void main_thread();

private:
    struct route_slot {
        bool valid;
        sc_dt::sc_bv<TAG_WIDTH> tag;
        uint32_t route_mask;  // K bits for connected positions
    };
    std::array<route_slot, NUM_ROUTE_TABLE> route_table;

    void decode_route_table();
    int match_tag(const sc_dt::sc_bv<TAG_WIDTH>& tag);
};
```

## config_mem Design

### Purpose

The `config_mem` controller provides a TLM 2.0 interface for runtime
configuration, equivalent to the AXI-Lite interface in RTL.

### TLM Interface

The config_mem uses `tlm_utils::simple_target_socket` for blocking transport:

```cpp
void my_cgra_top::b_transport(
    tlm::tlm_generic_payload& trans,
    sc_core::sc_time& delay
) {
    tlm::tlm_command cmd = trans.get_command();
    uint64_t addr = trans.get_address();
    uint8_t* data = trans.get_data_ptr();
    uint32_t len = trans.get_data_length();

    uint32_t word_idx = addr / 4;

    if (word_idx >= config_mem.size()) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        return;
    }

    if (cmd == tlm::TLM_READ_COMMAND) {
        // Host read
        uint32_t value = config_mem[word_idx];
        memcpy(data, &value, std::min(len, 4u));
    } else if (cmd == tlm::TLM_WRITE_COMMAND) {
        // Host write
        uint32_t value = 0;
        memcpy(&value, data, std::min(len, 4u));
        config_mem[word_idx] = value;
        propagate_config();  // Update module configurations
    }

    trans.set_response_status(tlm::TLM_OK_RESPONSE);
}
```

### Access Model

**config_mem is read-write from host (TLM initiator), read-only from
accelerator modules.**

- The host (testbench or software model) has full read-write access via TLM
- Fabric modules receive configuration through `sc_in` ports
- Fabric modules cannot modify config_mem during execution
- Configuration changes require the `propagate_config()` call to update module
  ports

### Address Allocation

Address allocation follows the same rules as RTL (see
[spec-adg-sv.md](./spec-adg-sv.md)):

1. Sequential allocation based on MLIR operation order
2. 32-bit word alignment for each configurable node
3. Unused bits within words are ignored on write, read as zero

The `<module>_addr.h` header is shared between SystemC and SystemVerilog
exports.

### Configuration Sequence

Software configures the accelerator by:

1. Assert reset (`rst_n = false`)
2. Write all config_mem words via TLM transactions
3. De-assert reset (`rst_n = true`)
4. Begin dataflow simulation

```cpp
// Example configuration sequence
void testbench::configure() {
    // Assert reset
    rst_n.write(false);
    wait(clk.posedge_event());

    // Write configuration via TLM
    tlm::tlm_generic_payload trans;
    sc_core::sc_time delay = sc_core::SC_ZERO_TIME;

    uint32_t config_data[] = { /* ... */ };
    for (size_t i = 0; i < config_size; i++) {
        trans.set_command(tlm::TLM_WRITE_COMMAND);
        trans.set_address(i * 4);
        trans.set_data_ptr(reinterpret_cast<uint8_t*>(&config_data[i]));
        trans.set_data_length(4);
        cfg_socket->b_transport(trans, delay);
    }

    // De-assert reset
    wait(clk.posedge_event());
    rst_n.write(true);
}
```

## Error Reporting

Each module reports errors through error signals:

```cpp
sc_core::sc_out<bool>     error_valid;
sc_core::sc_out<uint16_t> error_code;
```

Error codes match the values defined in
[spec-fabric-error.md](./spec-fabric-error.md):

- CFG_ errors (0-7): Configuration errors detected after programming
- RT_ errors (256+): Runtime execution errors

The top-level module aggregates errors using priority encoding (lower code =
higher priority). The first error is latched until reset.

**Error reporting example:**

```cpp
void fabric_temporal_pe::report_error(uint16_t code) {
    if (!error_valid.read()) {  // Only latch first error
        error_valid.write(true);
        error_code.write(code);
        SC_REPORT_ERROR("fabric_temporal_pe",
            ("Runtime error: code " + std::to_string(code)).c_str());
    }
}
```

## Testbench Generation

The generated testbench (`my_cgra_testbench.h/cpp`) provides:

1. Clock generation
2. Reset sequence
3. Configuration loading from binary file
4. Stimulus injection helpers
5. Output verification helpers
6. VCD trace generation

**Testbench structure:**

```cpp
SC_MODULE(my_cgra_testbench) {
    // Clock and reset
    sc_core::sc_clock clk;
    sc_core::sc_signal<bool> rst_n;

    // DUT instance
    my_cgra_top dut;

    // TLM initiator for configuration
    tlm_utils::simple_initiator_socket<my_cgra_testbench> cfg_init;

    // Streaming connections
    fabric::stream_signals<DATA_WIDTH> native_in_sig[NUM_NATIVE_INPUTS];
    fabric::stream_signals<DATA_WIDTH> native_out_sig[NUM_NATIVE_OUTPUTS];
    // ...

    SC_CTOR(my_cgra_testbench)
        : clk("clk", 10, sc_core::SC_NS)  // 100 MHz
        , dut("dut")
    {
        // Bind ports
        dut.clk(clk);
        dut.rst_n(rst_n);
        cfg_init.bind(dut.cfg_socket);
        // ...

        SC_THREAD(main_thread);
    }

    void main_thread();

    // Helper methods
    void reset();
    void configure(const std::string& config_file);
    void send_token(int port, uint64_t data);
    uint64_t receive_token(int port);
    void wait_cycles(int n);
};
```

**Example main.cpp:**

```cpp
#include "my_cgra_testbench.h"

int sc_main(int argc, char* argv[]) {
    // Parse arguments
    std::string config_file = "config.bin";
    if (argc > 1) config_file = argv[1];

    // Create testbench
    my_cgra_testbench tb("tb");

    // Enable VCD tracing
    sc_core::sc_trace_file* tf = sc_core::sc_create_vcd_trace_file("waves");
    sc_core::sc_trace(tf, tb.clk, "clk");
    sc_core::sc_trace(tf, tb.rst_n, "rst_n");
    // ... trace other signals

    // Run simulation
    sc_core::sc_start();

    // Cleanup
    sc_core::sc_close_vcd_trace_file(tf);

    return 0;
}
```

## Build System

### CMake Configuration

The generated `CMakeLists.txt` provides a complete build configuration:

```cmake
cmake_minimum_required(VERSION 3.16)
project(my_cgra_sysc CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find SystemC (prefer 3.0.2)
set(SYSTEMC_HOME "/path/to/tools/systemc/3.0.2" CACHE PATH "SystemC installation")
find_library(SYSTEMC_LIBRARY
    NAMES systemc
    PATHS ${SYSTEMC_HOME}/lib64 ${SYSTEMC_HOME}/lib
    NO_DEFAULT_PATH
)
find_path(SYSTEMC_INCLUDE_DIR
    NAMES systemc.h
    PATHS ${SYSTEMC_HOME}/include
    NO_DEFAULT_PATH
)

if(NOT SYSTEMC_LIBRARY OR NOT SYSTEMC_INCLUDE_DIR)
    message(FATAL_ERROR "SystemC not found. Set SYSTEMC_HOME.")
endif()

# Abstraction level selection
option(FABRIC_CYCLE_ACCURATE "Enable cycle-accurate simulation" ON)
if(FABRIC_CYCLE_ACCURATE)
    add_compile_definitions(FABRIC_SYSC_CYCLE_ACCURATE)
else()
    add_compile_definitions(FABRIC_SYSC_LOOSELY_TIMED)
endif()

# Library target (header-only)
add_library(fabric_lib INTERFACE)
target_include_directories(fabric_lib INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib
    ${SYSTEMC_INCLUDE_DIR}
)

# Main simulation executable
add_executable(my_cgra_sim
    my_cgra_top.cpp
    my_cgra_config.cpp
    my_cgra_testbench.cpp
    my_cgra_main.cpp
)
target_link_libraries(my_cgra_sim PRIVATE
    fabric_lib
    ${SYSTEMC_LIBRARY}
    pthread
)
target_include_directories(my_cgra_sim PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${SYSTEMC_INCLUDE_DIR}
)

# Installation
install(TARGETS my_cgra_sim DESTINATION bin)
install(FILES my_cgra_addr.h DESTINATION include)
```

### Build Commands

```bash
# Configure
cmake -B build -DSYSTEMC_HOME=/path/to/tools/systemc/3.0.2

# Build (cycle-accurate, default)
cmake --build build

# Build (loosely-timed)
cmake -B build -DFABRIC_CYCLE_ACCURATE=OFF
cmake --build build

# Run simulation
./build/my_cgra_sim config.bin
```

## Simulation Performance

### Cycle-Accurate Mode

- Timing: Exact cycle count matches RTL
- Speed: ~10-100x faster than RTL simulation (Verilator/VCS)
- Use case: Verification, debugging, small test cases

### Loosely-Timed Mode

- Timing: Approximate (quantum-based)
- Speed: ~100-1000x faster than cycle-accurate
- Use case: Software development, large workloads

**Quantum configuration:**

```cpp
// In testbench or main
sc_core::sc_set_time_resolution(1, sc_core::SC_PS);
tlm::tlm_global_quantum::instance().set(sc_core::sc_time(100, sc_core::SC_NS));
```

## Co-Simulation Support

The SystemC model supports co-simulation with RTL for verification. See
[spec-adg-tools.md](./spec-adg-tools.md) for detailed simulation workflows.

### Mixed SystemC/RTL Wrapper

```cpp
// Co-simulation wrapper comparing SystemC model with RTL
#include "Vmy_cgra_rtl.h"  // Verilated or VCS-compiled RTL
#include "my_cgra_top.h"   // SystemC model

SC_MODULE(cosim_wrapper) {
    Vmy_cgra_rtl rtl_dut;
    my_cgra_top  sysc_dut;

    // Compare outputs cycle-by-cycle
    SC_THREAD(compare_thread);
};
```

## Debugging Features

### Waveform Trace Generation

For waveform format priorities (FSDB > FST > VCD) and detailed simulation
workflows, see [spec-adg-tools.md](./spec-adg-tools.md).

**SystemC trace setup examples:**

```cpp
// FSDB tracing (VCS/Verdi)
#ifdef FABRIC_USE_FSDB
#include "fsdb_trace.h"
void testbench::setup_trace() {
    fsdbDumpfile("waves.fsdb");
    fsdbDumpvars(0, this);
}
#endif

// FST tracing (Verilator)
#ifdef FABRIC_USE_FST
#include "verilated_fst_sc.h"
void testbench::setup_trace() {
    Verilated::traceEverOn(true);
    VerilatedFstSc* tfp = new VerilatedFstSc;
    dut.trace(tfp, 99);
    tfp->open("waves.fst");
}
#endif

// VCD tracing (standard SystemC fallback)
#ifdef FABRIC_USE_VCD
sc_trace_file* tf = sc_create_vcd_trace_file("waves");
tf->set_time_unit(1, SC_NS);
sc_trace(tf, dut.clk, "top.clk");
sc_trace(tf, dut.rst_n, "top.rst_n");
#endif
```

### SC_REPORT Messages

The generated modules use `SC_REPORT_*` macros for diagnostic messages:

```cpp
SC_REPORT_INFO("fabric_pe", "Processing input token");
SC_REPORT_WARNING("fabric_switch", "Input has no enabled route");
SC_REPORT_ERROR("fabric_temporal_pe", "Tag mismatch: no instruction found");
```

Control verbosity at runtime:

```cpp
sc_core::sc_report_handler::set_verbosity_level(sc_core::SC_DEBUG);
```

### Assertions

The generated code includes assertions gated by `SC_INCLUDE_DYNAMIC_PROCESSES`:

```cpp
#ifdef FABRIC_SYSC_ASSERTIONS
    sc_assert(in_valid[i].read() || !pending_output);
#endif
```

Enable assertions:

```bash
cmake -DFABRIC_SYSC_ASSERTIONS=ON ...
```

## Related Documents

- [spec-adg.md](./spec-adg.md): ADG overall design
- [spec-adg-api.md](./spec-adg-api.md): ADGBuilder API reference
- [spec-adg-tools.md](./spec-adg-tools.md): Simulation tools and waveform formats
- [spec-adg-sv.md](./spec-adg-sv.md): SystemVerilog generation specification
- [spec-fabric.md](./spec-fabric.md): Fabric MLIR dialect specification
- [spec-fabric-error.md](./spec-fabric-error.md): Error code definitions
